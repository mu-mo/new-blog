<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>effective python 学习笔记 | my blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Python,effective - 学习笔记," />
  

  <meta name="description" content="人生苦短我用 Python 注：最后附电子书地址 一、Pythonic Thinking第1条: 确认自己所用的Python版本 使用python -version查看当前Python版本 Python的运行时版本：CPython，JyPython，IronPython和PyPy等 优先考虑使用 Python 3  第2条: 遵循PEP 8 风格指南PEP 8：http://www.python.">
<meta name="keywords" content="Python,effective - 学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="effective python 学习笔记">
<meta property="og:url" content="http://mu-mo.top/2018/05/01/Python/effective python学习笔记/index.html">
<meta property="og:site_name" content="my blog">
<meta property="og:description" content="人生苦短我用 Python 注：最后附电子书地址 一、Pythonic Thinking第1条: 确认自己所用的Python版本 使用python -version查看当前Python版本 Python的运行时版本：CPython，JyPython，IronPython和PyPy等 优先考虑使用 Python 3  第2条: 遵循PEP 8 风格指南PEP 8：http://www.python.">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-08-05T09:12:40.508Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="effective python 学习笔记">
<meta name="twitter:description" content="人生苦短我用 Python 注：最后附电子书地址 一、Pythonic Thinking第1条: 确认自己所用的Python版本 使用python -version查看当前Python版本 Python的运行时版本：CPython，JyPython，IronPython和PyPy等 优先考虑使用 Python 3  第2条: 遵循PEP 8 风格指南PEP 8：http://www.python.">

  

  
    <link rel="icon" href="/images/favicon.ico">
  

  <link href="/css/styles.css?v=c114cben" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?64b0816fa55321a78a9c75c6ded29a29";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives"
            rel="noopener noreferrer"
            target="_self"
            >
            blog
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Pythonic-Thinking"><span class="toc-text">一、Pythonic Thinking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第1条-确认自己所用的Python版本"><span class="toc-text">第1条: 确认自己所用的Python版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第2条-遵循PEP-8-风格指南"><span class="toc-text">第2条: 遵循PEP 8 风格指南</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#空白"><span class="toc-text">空白:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名"><span class="toc-text">命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表达式和语句-Python之禅：-每件事都应该有直白的做法，而且最好只有一种"><span class="toc-text">表达式和语句( Python之禅： 每件事都应该有直白的做法，而且最好只有一种 )</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第3条-了解-bytes、str与-unicode-的区别"><span class="toc-text">第3条: 了解 bytes、str与 unicode 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录："><span class="toc-text">备忘录：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第4条：用辅助函数来取代复杂的表达式"><span class="toc-text">第4条：用辅助函数来取代复杂的表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第5条：了解切割序列的办法"><span class="toc-text">第5条：了解切割序列的办法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第6条-避免在单次切片操作内同事指定-start、end和-stride（个人觉得还好）"><span class="toc-text">第6条: 避免在单次切片操作内同事指定 start、end和 stride（个人觉得还好）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录：-1"><span class="toc-text">备忘录：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#步幅"><span class="toc-text">步幅</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#负数步幅"><span class="toc-text">负数步幅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第7条-用列表推导来代替-map-和-filter"><span class="toc-text">第7条: 用列表推导来代替 map 和 filter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第8条-在列表表达式中避免使用超过两个的表达式"><span class="toc-text">第8条: 在列表表达式中避免使用超过两个的表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录：-2"><span class="toc-text">备忘录：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第一个例子："><span class="toc-text">第一个例子：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二个例子："><span class="toc-text">第二个例子：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三个例子："><span class="toc-text">第三个例子：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第9条-数据量较大的地方考虑使用生成器表达式"><span class="toc-text">第9条: 数据量较大的地方考虑使用生成器表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-1"><span class="toc-text">备忘录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#列表生成式的缺点"><span class="toc-text">列表生成式的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成器表达式的好处"><span class="toc-text">生成器表达式的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第10条：enumerate-比range更好用"><span class="toc-text">第10条：enumerate 比range更好用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录：-3"><span class="toc-text">备忘录：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第11条：用-zip-函数来同时遍历两个迭代器"><span class="toc-text">第11条：用 zip 函数来同时遍历两个迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-2"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第12条-在for-和while-循环体后避免使用else语句块"><span class="toc-text">第12条: 在for 和while 循环体后避免使用else语句块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-3"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第13条-合理利用-try-except-else-finally"><span class="toc-text">第13条: 合理利用 try/except/else/finally</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-4"><span class="toc-text">备忘录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、函数"><span class="toc-text">二、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第14条-返回-exceptions-而不是-None"><span class="toc-text">第14条: 返回 exceptions 而不是 None</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-5"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第15条-了解闭包中是怎样使用外围作用域变量"><span class="toc-text">第15条: 了解闭包中是怎样使用外围作用域变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-6"><span class="toc-text">备忘录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#把数据放到外边"><span class="toc-text">把数据放到外边</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python2中的作用域"><span class="toc-text">Python2中的作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第16条-考虑使用生成器而不是返回列表"><span class="toc-text">第16条: 考虑使用生成器而不是返回列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-7"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第17条-遍历参数的时候小心一点"><span class="toc-text">第17条: 遍历参数的时候小心一点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-8"><span class="toc-text">备忘录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案："><span class="toc-text">解决方案：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第18条-减少位置参数上的干扰"><span class="toc-text">第18条: 减少位置参数上的干扰</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-9"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第19条-使用关键字参数来提供可选行为"><span class="toc-text">第19条: 使用关键字参数来提供可选行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-10"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第20条-使用None和文档说明动态的指定默认参数"><span class="toc-text">第20条: 使用None和文档说明动态的指定默认参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-11"><span class="toc-text">备忘录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第一个例子：-1"><span class="toc-text">第一个例子：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二个例子：-1"><span class="toc-text">第二个例子：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第21条-仅强调关键字参数"><span class="toc-text">第21条: 仅强调关键字参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-12"><span class="toc-text">备忘录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、类和继承"><span class="toc-text">三、类和继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第22条-尽量使用辅助类来维护程序的状态，避免dict嵌套dict或大tuple"><span class="toc-text">第22条: 尽量使用辅助类来维护程序的状态，避免dict嵌套dict或大tuple</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-13"><span class="toc-text">备忘录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重构成多个类"><span class="toc-text">重构成多个类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第23条-对于简单接口使用函数而不是类的实例"><span class="toc-text">第23条: 对于简单接口使用函数而不是类的实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-14"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第24条-使用-classmethod多态性构造对象"><span class="toc-text">第24条: 使用@classmethod多态性构造对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-15"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第25条-使用super关键字初始化父类"><span class="toc-text">第25条: 使用super关键字初始化父类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-16"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第26条-只在用编写Max-in组件的工具类的时候使用多继承"><span class="toc-text">第26条: 只在用编写Max-in组件的工具类的时候使用多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-17"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第27条-多使用公共属性，而不是私有属性"><span class="toc-text">第27条: 多使用公共属性，而不是私有属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-18"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第28条-自定义容器类型要从collections-abc来继承"><span class="toc-text">第28条:自定义容器类型要从collections.abc来继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-19"><span class="toc-text">备忘录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、元类和属性"><span class="toc-text">四、元类和属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第29条-用纯属性取代-get-和-set-方法"><span class="toc-text">第29条: 用纯属性取代 get 和 set 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-20"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第30条-考虑-property来替代属性重构"><span class="toc-text">第30条: 考虑@property来替代属性重构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-21"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第31条-用描述符来改写需要复用的-property-方法"><span class="toc-text">第31条: 用描述符来改写需要复用的 @property 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-22"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第32条-用-getattr-getattribute-和-setattr-实现按需生产的属性"><span class="toc-text">第32条: 用 __getattr__, __getattribute__,  和__setattr__ 实现按需生产的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-23"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第33条-用元类来验证子类"><span class="toc-text">第33条: 用元类来验证子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-24"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第34条-用元类来注册子类"><span class="toc-text">第34条: 用元类来注册子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-25"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第35-用元类来注解类的属性"><span class="toc-text">第35: 用元类来注解类的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-26"><span class="toc-text">备忘录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、并行与并发"><span class="toc-text">五、并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第36条-用-subprocess-模块来管理子进程"><span class="toc-text">第36条: 用 subprocess 模块来管理子进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-27"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第37条-可以用线程来执行阻塞时I-O，但不要用它做平行计算"><span class="toc-text">第37条: 可以用线程来执行阻塞时I/O，但不要用它做平行计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-28"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第38条-在线程中使用Lock来防止数据竞争"><span class="toc-text">第38条: 在线程中使用Lock来防止数据竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-29"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第39条-用-Queue-来协调各线程之间的工作"><span class="toc-text">第39条: 用 Queue 来协调各线程之间的工作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-30"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第40条-考虑用协程来并发地运行多个函数"><span class="toc-text">第40条: 考虑用协程来并发地运行多个函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-31"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第41条-考虑用-concurrent-futures-来实现真正的并行计算"><span class="toc-text">第41条: 考虑用 concurrent.futures 来实现真正的并行计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-32"><span class="toc-text">备忘录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、内置模块"><span class="toc-text">六、内置模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第42条-用-functools-wraps-定义函数修饰器"><span class="toc-text">第42条: 用 functools.wraps 定义函数修饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-33"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第43条-考虑用-contextlib-和with-语句来改写可复用的-try-finally-代码"><span class="toc-text">第43条: 考虑用 contextlib 和with 语句来改写可复用的 try/finally 代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-34"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第44条-用-copyreg-实现可靠的-pickle-操作"><span class="toc-text">第44条: 用 copyreg 实现可靠的 pickle 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-35"><span class="toc-text">备忘录</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Default-Attribute-Values"><span class="toc-text">Default Attribute Values</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Versioning-Classes"><span class="toc-text">Versioning Classes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stable-Import-Paths"><span class="toc-text">Stable Import Paths</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第45条-用-datetime-替代-time-来处理本地时间"><span class="toc-text">第45条: 用 datetime 替代 time 来处理本地时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-36"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第46条-使用内置算法与数据结构"><span class="toc-text">第46条: 使用内置算法与数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-37"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第47-条-在重视-精确度的场合，应该使用-decimal"><span class="toc-text">第47 条: 在重视 精确度的场合，应该使用 decimal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-38"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第48条-学会安装由-Python-开发者社区所构建的模块"><span class="toc-text">第48条: 学会安装由 Python 开发者社区所构建的模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、协作开发"><span class="toc-text">七、协作开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第49条-为每个函数、类和模块编写文档字符串"><span class="toc-text">第49条: 为每个函数、类和模块编写文档字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第50条-用包来安排模块，并提供稳固的-API"><span class="toc-text">第50条: 用包来安排模块，并提供稳固的 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第51条-为自编的模块定义根异常，以便将调用者与-API-相隔离"><span class="toc-text">第51条: 为自编的模块定义根异常，以便将调用者与 API 相隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第52条-用适当的方式打破循环依赖问题"><span class="toc-text">第52条: 用适当的方式打破循环依赖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第53条-用虚拟环境隔离项目，并重建其依赖关系"><span class="toc-text">第53条: 用虚拟环境隔离项目，并重建其依赖关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、部署"><span class="toc-text">八、部署</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第54条-考虑用模块级别的代码来配置不同的部署环境"><span class="toc-text">第54条: 考虑用模块级别的代码来配置不同的部署环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第55条-通过-repr-字符串来输出调试信息"><span class="toc-text">第55条: 通过 repr 字符串来输出调试信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-39"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第56条-用-unittest-来测试全部代码"><span class="toc-text">第56条: 用 unittest 来测试全部代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-40"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第57条-考虑用-pdb-实现交互调试"><span class="toc-text">第57条: 考虑用 pdb 实现交互调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-41"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第58条-先分析性能再优化"><span class="toc-text">第58条: 先分析性能再优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第59条-用-tracemaloc-来掌握内存的使用及泄露情况"><span class="toc-text">第59条: 用 tracemaloc 来掌握内存的使用及泄露情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#备忘录-42"><span class="toc-text">备忘录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考书籍"><span class="toc-text">参考书籍</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Python/effective python学习笔记" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">
      effective python 学习笔记
    </h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>
          2018.05.01
        </span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>
            mu-mo
          </span>
        </span>
        

          
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </span>



            
              <span>
                <i class="icon-comment"></i>
                <a href="https://mu-mo.top/2018/05/01/Python/effective python学习笔记/#disqus_thread"></a>
              </span>
              

                
                  <i class="fa fa-eye"></i>
                  <span id="busuanzi_container_page_pv">
                    &nbsp热度
                    <span id="busuanzi_value_page_pv">
                      <i class="fa fa-spinner fa-spin"></i>
                    </span>℃
                  </span>
                  
    </div>
  </header>

  <div class="article-content">
    
              <p><em>人生苦短我用 Python</em></p>
<p><em>注：最后附电子书地址</em></p>
<h2 id="一、Pythonic-Thinking"><a href="#一、Pythonic-Thinking" class="headerlink" title="一、Pythonic Thinking"></a>一、Pythonic Thinking</h2><h3 id="第1条-确认自己所用的Python版本"><a href="#第1条-确认自己所用的Python版本" class="headerlink" title="第1条: 确认自己所用的Python版本"></a>第1条: 确认自己所用的Python版本</h3><ul>
<li>使用python -version查看当前Python版本</li>
<li>Python的运行时版本：CPython，JyPython，IronPython和PyPy等</li>
<li>优先考虑使用 Python 3</li>
</ul>
<h3 id="第2条-遵循PEP-8-风格指南"><a href="#第2条-遵循PEP-8-风格指南" class="headerlink" title="第2条: 遵循PEP 8 风格指南"></a>第2条: 遵循PEP 8 风格指南</h3><p>PEP 8：<a href="http://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">http://www.python.org/dev/peps/pep-0008/</a></p>
<p>PEP 8：<a href="http://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">http://www.python.org/dev/peps/pep-0008/</a></p>
<h4 id="空白"><a href="#空白" class="headerlink" title="空白:"></a>空白:</h4><ul>
<li>不要使用 tab 缩进，使用空格来缩进</li>
<li>使用四个空格缩进，使用四个空格对长表达式换行缩进</li>
<li>每行的字符数不应该超过 79</li>
<li>class和funciton之间用两个空行，class的method之间用一个空行</li>
<li>list索引和函数调用，关键字参数赋值不要在两旁加空格</li>
<li>变量赋值前后都用一个空格</li>
</ul>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li>函数，变量以及属性应该使用小写，如果有多个单词推荐使用下划线进行连接，如lowercase_underscore</li>
<li><strong>被保护</strong> 的属性应该使用 <strong>单个</strong> 前导下划线来声明。</li>
<li><strong>私有</strong> 的属性应该使用 <strong>两个</strong> 前导下划线来进行声明。</li>
<li><strong>类以及异常信息</strong> 应该使用单词 <strong>首字母大写</strong> 形式，也就是我们经常使用的驼峰命名法，如CapitalizedWord。</li>
<li><strong>模块级</strong> 别的常量应该使用 <strong>全部大写</strong> 的形式, 如ALL_CAPS。</li>
<li>类内部的实例方法的应该将<code>self</code>作为其第一个参数。且<code>self</code>也是对当前类对象的引用。</li>
<li>类方法应该使用<code>cls</code>来作为其第一个参数。且<code>self</code>引用自当前类。</li>
</ul>
<h4 id="表达式和语句-Python之禅：-每件事都应该有直白的做法，而且最好只有一种"><a href="#表达式和语句-Python之禅：-每件事都应该有直白的做法，而且最好只有一种" class="headerlink" title="表达式和语句( Python之禅： 每件事都应该有直白的做法，而且最好只有一种 )"></a>表达式和语句( <strong>Python之禅： 每件事都应该有直白的做法，而且最好只有一种</strong> )</h4><ul>
<li>使用内联否定（如 <code>if a is not b</code>） 而不是显示的表达式（如<code>if not a is b</code>）。</li>
<li>不要简单地通过变量的长度（<code>if len(somelist) == 0</code>）来判断空值。使用隐式的方式如来假设空值的情况（如<code>if not somelist</code> 与 <code>False</code>来进行比较）。</li>
<li>上面的第二条也适用于非空值（如<code>[1]</code>,或者’hi’）。对这些非空值而言 <code>if somelist</code>默认包含隐式的<code>True</code>。</li>
<li>避免将<code>if</code> , <code>for</code>, <code>while</code>, <code>except</code>等包含多个语块的表达式写在一行内，应该分割成多行。</li>
<li>总是把<code>import</code>语句写在<code>Python</code>文件的顶部。</li>
<li>当引用一个模块的时候使用绝对的模块名称，而不是与当前模块路径相关的名称。例如要想引入<code>bar</code>包下面的<code>foo</code>模块，应该使用<code>from bar import foo</code>而不是<code>import foo</code>。</li>
<li>如果非要相对的引用，应该使用明确的语法<code>from . import foo</code>。</li>
<li>按照以下规则引入模块：标准库，第三方库，你自己的库。每一个部分内部也应该按照字母顺序来引入。</li>
</ul>
<h3 id="第3条-了解-bytes、str与-unicode-的区别"><a href="#第3条-了解-bytes、str与-unicode-的区别" class="headerlink" title="第3条: 了解 bytes、str与 unicode 的区别"></a>第3条: 了解 bytes、str与 unicode 的区别</h3><h4 id="备忘录："><a href="#备忘录：" class="headerlink" title="备忘录："></a>备忘录：</h4><ul>
<li>Python3 两种字符串类型：bytes和str，bytes表示8-bit的二进制值，str表示unicode字符</li>
<li>Python2 两种字符串类型：str和unicode，str表示8-bit的二进制值，unicode表示unicode字符</li>
<li>从文件中读取或者写入二进制数据时，总应该使用 ‘rb’ 或 ‘wb’ 等二进制模式来开启文件</li>
</ul>
<p>​      <code>Python3</code>中的<code>str</code>实例和<code>Python2</code>中的<code>unicode</code>实例并没有相关联的二进制编码。所以要想将<code>Unicode</code>字符转换成二进制数据，就必须使用<code>encode</code>方法，反过来，要想把二进制数据转换成<code>Unicode</code>字符，就必须使用<code>decode</code>方法。</p>
<p>​      当你开始写<code>Python</code>程序的时候，在接口的最开始位置声明对<code>Unicode</code>的编码解码的细节很重要。在你的代码中，最核心的部分应使用<code>Unicode</code>字符类型（<code>Python3</code>中使用<code>str</code>,<code>Python2</code>中使用<code>unicode</code>）并且不应该考虑关于字符编码的任何其他方式。本文允许你使用自己喜欢的可替代性的文本编码方式（如<code>Latin-1</code>,<code>Shift JIS</code>, <code>Big5</code>），但是应该对你的文本输出编码严格的限定一下（理想的方式是使用<code>UTF-8</code>编码）。</p>
<p>由于字符类型的不同，导致了Python代码中出现了两种常见的情形的发生。</p>
<ul>
<li><p>你想操作<code>UTF-8</code>（或者其他的编码方式）编码的8比特值 序列。</p>
</li>
<li><p>你想操作没有特定编码的<code>Unicode</code>字符。 所以你通常会需要两个工具函数来对这两种情况的字符进行转换，以此来确保输入值符合代码所预期的字符类型。</p>
</li>
<li><p>二进制值和unicode字符需要经过encode和decode转换，Python2的unicode和Python3的str没有关联二进制编码，通常使用UTF-8</p>
</li>
<li><p>Python2转换函数：</p>
<ul>
<li><p>to_unicode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_unicode</span><span class="params">(unicode_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(unicode_or_str, str):</span><br><span class="line">        value = unicode_or_str.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = unicode_or_str</span><br><span class="line">    <span class="keyword">return</span> value <span class="comment"># Instance of unicode</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>to_str</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(unicode_or_str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(unicode_or_str, unicode):</span><br><span class="line">        value = unicode_or_str.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = unicode_or_str</span><br><span class="line">    <span class="keyword">return</span> value <span class="comment"># Instance of str</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Python2，如果str只包含7-bit的ascii字符，unicode和str是一样的类型，所以：</p>
<ul>
<li>使用+连接：str + unicode</li>
<li>可以对str和unicode进行比较</li>
<li>unicode可以使用格式字符串，’%s’</li>
</ul>
<p>注：在Python2中，如果只处理7位ASCII的情形下，可以等价 str 和 unicode 上面的规则，在Python3中 bytes 和 str 实例绝不等价</p>
</li>
<li><p>使用open返回的文件操作，在Python3是默认进行UTF-8编码，但在Pyhton2是二进制编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">with</span> open(‘/tmp/random.bin’, ‘w’) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># &gt;&gt;&gt;</span></span><br><span class="line"><span class="comment">#TypeError: must be str, not bytes</span></span><br></pre></td></tr></table></figure>
<p>这时我们可以用二进制方式进行写入和读取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/random.bin'</span>,<span class="string">'wb) as f:</span></span><br><span class="line"><span class="string">    f.write(os.urandom(10))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第4条：用辅助函数来取代复杂的表达式"><a href="#第4条：用辅助函数来取代复杂的表达式" class="headerlink" title="第4条：用辅助函数来取代复杂的表达式"></a>第4条：用辅助函数来取代复杂的表达式</h3><ul>
<li>开发者很容易过度使用Python的语法特效，从而写出那种特别复杂并且难以理解的单行表达式</li>
<li>请把复杂的表达式移入辅助函数中，如果要反复使用相同的逻辑，那就更应该这么做</li>
<li>使用 if/else 表达式，要比使用 or 或者 and 这样的 Booolean 操作符更加清晰</li>
</ul>
<h3 id="第5条：了解切割序列的办法"><a href="#第5条：了解切割序列的办法" class="headerlink" title="第5条：了解切割序列的办法"></a>第5条：了解切割序列的办法</h3><ul>
<li><p>分片机制自动处理越界问题，但是最好在表达边界大小范围是更加的清晰。（如<code>a[:20]</code> 或者<code>a[-20:]</code>）</p>
</li>
<li><p>list，str，bytes和实现__getitem__和__setitem__ 这两个特殊方法的类都支持slice操作</p>
</li>
<li><p>基本形式是：somelist[start:end]，不包括end，可以使用负数，-1 表示最后一个，默认正向选取，下标0可以省略，最后一个下标也可以省略</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</span><br><span class="line">print(<span class="string">'Middle Two:'</span>,a[<span class="number">3</span>:<span class="number">-3</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Middle Two: [<span class="string">'d'</span>,<span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>slice list是shadow copy，somelist[0:]会复制原list，切割之后对新得到的列表进行修改不会影响原来的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</span><br><span class="line">b = a[<span class="number">4</span>:]</span><br><span class="line">print(<span class="string">"Before:"</span>, b)</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">99</span></span><br><span class="line">print(<span class="string">"After:"</span>,b)</span><br><span class="line">print(<span class="string">"Original:"</span>,a)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Before: [<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</span><br><span class="line">After: [<span class="string">'e'</span>,<span class="number">99</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</span><br><span class="line">Original: [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>slice赋值会修改slice list，即使长度不一致（增删改）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;Before:&quot;,a)</span><br><span class="line">a[2:7] = [99,22,14]</span><br><span class="line">print(&quot;After:&quot;,a)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Before: [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;]</span><br><span class="line">After: [&apos;a&apos;,&apos;b&apos;,99,22,14,&apos;h&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用-变化-追随</p>
<p>当为列表赋值的时候省去开头和结尾下标的时候，将会用 <strong>这个引用</strong> 来替换整个列表的内容，而不是创建一个新的列表。同时，引用了这个列表的列表的相关内容，也会跟着发生变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</span><br><span class="line">b = a</span><br><span class="line">print(<span class="string">"Before:"</span>,b)</span><br><span class="line">a[:] = [<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>]</span><br><span class="line">print(<span class="string">"After:"</span>,b)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Before: [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</span><br><span class="line">After: [<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方案：深拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">b = copy.copy(a)</span><br><span class="line">print(<span class="string">"Before:"</span>,b)</span><br><span class="line">a[:] = [<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>]</span><br><span class="line">print(<span class="string">"After:"</span>,b)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Before: [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</span><br><span class="line">After: [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第6条-避免在单次切片操作内同事指定-start、end和-stride（个人觉得还好）"><a href="#第6条-避免在单次切片操作内同事指定-start、end和-stride（个人觉得还好）" class="headerlink" title="第6条: 避免在单次切片操作内同事指定 start、end和 stride（个人觉得还好）"></a>第6条: 避免在单次切片操作内同事指定 start、end和 stride（个人觉得还好）</h3><h4 id="备忘录：-1"><a href="#备忘录：-1" class="headerlink" title="备忘录："></a>备忘录：</h4><ul>
<li>在分片中指定<code>start</code>，<code>end</code>,<code>stride</code>会让人感到困惑，难于阅读。</li>
<li>尽可能的避免在分片中使用负数值。</li>
<li>避免在分片中同时使用<code>start</code>，<code>end</code>，<code>stride</code>；如果非要使用，考虑两次赋值（一个分片，一个调幅），或者使用内置模块<code>itertoolsde</code> 的 <code>islice</code>方法来进行处理。</li>
</ul>
<h4 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h4><p><code>Python</code> 有针对步幅的特殊的语法，形如：<code>somelist[start:end:stride]</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'red'</span>,<span class="string">'orange'</span>,<span class="string">'yellow'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>,<span class="string">'purple'</span>]</span><br><span class="line">odds = a[::<span class="number">2</span>]</span><br><span class="line">print(odds)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">'red'</span>,<span class="string">'yellow'</span>,<span class="string">'blue'</span>]</span><br></pre></td></tr></table></figure>
<h4 id="负数步幅"><a href="#负数步幅" class="headerlink" title="负数步幅"></a>负数步幅</h4><p>步幅为-1来实现字符串的逆序，反向选取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当数据仅仅为ASCII码内数据时工作正常</span></span><br><span class="line">x = <span class="string">b'mongoose'</span></span><br><span class="line">y = x[::<span class="number">-1</span>]</span><br><span class="line">print(y)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="string">b'esoognom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现Unicode字符的时候就会报错</span></span><br><span class="line">w = <span class="string">'谢谢'</span></span><br><span class="line">x = w.encode(utf<span class="number">-8</span><span class="string">')</span></span><br><span class="line"><span class="string">y = a[::-1]</span></span><br><span class="line"><span class="string">z = y.decode('</span>utf<span class="number">-8</span><span class="string">')</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">UnicodeDecodeError: '</span>utf<span class="number">-8</span><span class="string">' codec can'</span>t decode byte <span class="number">0x9d</span> <span class="keyword">in</span> position <span class="number">0</span>: invalid start byte.</span><br><span class="line">        </span><br><span class="line">a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</span><br><span class="line">a[<span class="number">2</span>::<span class="number">2</span>]     <span class="comment"># ['c','e','g']</span></span><br><span class="line">a[<span class="number">-2</span>::<span class="number">-2</span>]    <span class="comment"># ['g','e','c','a']</span></span><br><span class="line">a[<span class="number">-2</span>:<span class="number">2</span>:<span class="number">-2</span>]   <span class="comment"># ['g','e'] 尤其注意这里，类似于坐标轴，分片范围是左闭右开，所以2的位置不可达</span></span><br><span class="line">a[<span class="number">2</span>:<span class="number">2</span>:<span class="number">-2</span>]    <span class="comment"># []</span></span><br></pre></td></tr></table></figure>
<h3 id="第7条-用列表推导来代替-map-和-filter"><a href="#第7条-用列表推导来代替-map-和-filter" class="headerlink" title="第7条: 用列表推导来代替 map 和 filter"></a>第7条: 用列表推导来代替 map 和 filter</h3><h4 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>列表表达式比内置的<code>map</code>,<code>filter</code>更加清晰，因为<code>map</code>,<code>filter</code>需要额外的<code>lambda</code>表达式的支持。</li>
<li>列表表达式允许你很容易的跳过某些输入值，而一个<code>map</code>没有<code>filter</code>帮助的话就不能完成这一个功能。</li>
<li>字典和集合也都支持列表表达式。</li>
</ul>
<p>第一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">squares = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">print(squares)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>,<span class="number">49</span>,<span class="number">64</span>,<span class="number">81</span>,<span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>map和filter需要lambda函数，使得代码更不可读</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = map(<span class="keyword">lambda</span> x: x **<span class="number">2</span> ,a)</span><br></pre></td></tr></table></figure>
<p>第二个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">even_squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line">print(even_squares)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">4</span>,<span class="number">16</span>,<span class="number">36</span>,<span class="number">64</span>,<span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>map：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alt = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, filter(<span class="keyword">lambda</span> x: x%<span class="number">2</span>==<span class="number">0</span>,a))</span><br><span class="line"><span class="keyword">assert</span> even_squares== list(alt)</span><br></pre></td></tr></table></figure>
<p><strong>字典和集合</strong> 有他们自己的一套列表表达式。这使得书写算法的时候导出数据结构更加的简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chile_rank = &#123;<span class="string">'ghost'</span>:<span class="number">1</span>,<span class="string">'habanero'</span>:<span class="number">2</span>,<span class="string">'cayenne'</span>:<span class="number">3</span>&#125;</span><br><span class="line">rank_dict = &#123;rank:name <span class="keyword">for</span> name,rank <span class="keyword">in</span> child_rank.items()&#125;</span><br><span class="line">chile_len_set = &#123;len(name) <span class="keyword">for</span> name <span class="keyword">in</span> rank_dict.values()&#125;</span><br><span class="line">print(rand_dict)</span><br><span class="line">print(chile_len_set)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'ghost'</span>,<span class="number">2</span>: <span class="string">'habanero'</span>,<span class="number">3</span>: <span class="string">'cayenne'</span>&#125;</span><br><span class="line">&#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第8条-在列表表达式中避免使用超过两个的表达式"><a href="#第8条-在列表表达式中避免使用超过两个的表达式" class="headerlink" title="第8条: 在列表表达式中避免使用超过两个的表达式"></a>第8条: 在列表表达式中避免使用超过两个的表达式</h3><h4 id="备忘录：-2"><a href="#备忘录：-2" class="headerlink" title="备忘录："></a>备忘录：</h4><ul>
<li>列表表达式支持多层的循环和条件语句，以及每层循环内部的条件语句。</li>
<li>当列表表达式内部多余两个表达式的时候就会变得难于阅读，这种写法应该避免使用。</li>
</ul>
<h4 id="第一个例子："><a href="#第一个例子：" class="headerlink" title="第一个例子："></a>第一个例子：</h4><p>not:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squared = [[ x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]</span><br><span class="line">print(squared)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>],[<span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>],[<span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]]</span><br></pre></td></tr></table></figure>
<p>prefer:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br><span class="line">print(flat)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h4 id="第二个例子："><a href="#第二个例子：" class="headerlink" title="第二个例子："></a>第二个例子：</h4><p>not:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_lists = [</span><br><span class="line">    [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]],</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">]</span><br><span class="line">flat = [ x <span class="keyword">for</span> sublist <span class="keyword">in</span> my_lists</span><br><span class="line">          <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist</span><br><span class="line">          <span class="keyword">for</span> x <span class="keyword">in</span> sublist2]</span><br><span class="line"></span><br><span class="line">print(flat)</span><br></pre></td></tr></table></figure>
<p>prefer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flat = []</span><br><span class="line"><span class="keyword">for</span> sublist <span class="keyword">in</span> my_lists:</span><br><span class="line">    <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist:</span><br><span class="line">        flat.append(sublist2)</span><br></pre></td></tr></table></figure>
<p>从这点来看，多行的列表表达式并不比原方案少多少代码。这里，作者更加的建议使用正常的循环体语句。因为其比列表表达式更简洁好看一点,也更加易读，易懂。</p>
<h4 id="第三个例子："><a href="#第三个例子：" class="headerlink" title="第三个例子："></a>第三个例子：</h4><p>列表表达式同样支持if条件语句。多个条件语句出现在相同的循环水平中也是一个隐式<code>&amp;</code>的表达,即同时成立才成立。例如：你只想获得列表中大于4且是偶数的值。那么下面的两个列表表达式是等价的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x&gt; <span class="number">4</span> <span class="keyword">if</span> x%<span class="number">2</span> ==<span class="number">0</span>]</span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">if</span> x%<span class="number">2</span> ==<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>条件语句可以被很明确的添加在每一层循环的<code>for</code>表达式的后面，起到过滤的作用。例如：你想过滤出每行总和大于10且能被3正处的元素。虽然用列表表达式表示出这段代码很短，但是其可读性确实很糟糕。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix = [[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">filtered = [[x <span class="keyword">for</span> x <span class="keyword">in</span> row <span class="keyword">if</span> x%<span class="number">3</span>==<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">if</span> sum(row) &gt;= <span class="number">10</span> ]</span><br><span class="line">print(filtered)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[[<span class="number">6</span>],[<span class="number">9</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="第9条-数据量较大的地方考虑使用生成器表达式"><a href="#第9条-数据量较大的地方考虑使用生成器表达式" class="headerlink" title="第9条: 数据量较大的地方考虑使用生成器表达式"></a>第9条: 数据量较大的地方考虑使用生成器表达式</h3><h4 id="备忘录-1"><a href="#备忘录-1" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>当遇到大输入事件的时候，使用列表表达式可能导致一些问题。</li>
<li>生成器表达式通过迭代的方式来处理每一个列表项，可以防止出现内存危机。</li>
<li>当生成器表达式 处于链式状态时，会执行的很迅速。</li>
</ul>
<h4 id="列表生成式的缺点"><a href="#列表生成式的缺点" class="headerlink" title="列表生成式的缺点"></a>列表生成式的缺点</h4><p>列表生成式会给输入列表中的每一个只创建一个新的只包含一个元素的列表。这对于小的输入序列可能是很好用的，但是大的输入序列而言就很有可能导致你的程序崩溃。</p>
<h4 id="生成器表达式的好处"><a href="#生成器表达式的好处" class="headerlink" title="生成器表达式的好处"></a>生成器表达式的好处</h4><p><code>Python</code>提供了一个<code>generator expression</code>（生成器表达式），在程序运行的过程中，生成其表达式不实现整个输出序列，相反,生成其表达式仅仅是对从表达式中产生一个项目的迭代器进行计算，说白了就是每次仅仅处理一个迭代项，而不是整个序列。</p>
<p>生成器表达式通过使用类似于列表表达式的语法（在<code>()</code>之间而不是<code>[]</code>之间，仅此区别）来创建。</p>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">it = ( len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(<span class="string">'/tmp/my_file.txt'</span>))</span><br><span class="line">print(it)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x101b81480</span>&gt;</span><br><span class="line"></span><br><span class="line">print(next(it))</span><br><span class="line">print(next(it))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">57</span></span><br></pre></td></tr></table></figure>
<p>链式操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">roots = ((x,x**<span class="number">0.5</span>) <span class="keyword">for</span> x <span class="keyword">in</span> it)</span><br><span class="line">print(next(roots))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">(<span class="number">15</span>,<span class="number">3.872983346207417</span>)</span><br></pre></td></tr></table></figure>
<h3 id="第10条：enumerate-比range更好用"><a href="#第10条：enumerate-比range更好用" class="headerlink" title="第10条：enumerate 比range更好用"></a>第10条：enumerate 比range更好用</h3><h4 id="备忘录：-3"><a href="#备忘录：-3" class="headerlink" title="备忘录："></a>备忘录：</h4><ul>
<li><code>enumerate</code>提供了简洁的语法，再循环迭代一个迭代器的同时既能获取下标，也能获取当前值。</li>
<li>可以添加第二个参数来指定 索引开始的序号，默认为<code>0</code></li>
</ul>
<p>Prefer</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, flavor <span class="keyword">in</span> enumerate(flavor_list):</span><br><span class="line">    print(‘%d: %s’ % (i + <span class="number">1</span>, flavor))</span><br></pre></td></tr></table></figure>
<p>not</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(flavor_list)):</span><br><span class="line">    flavor = flavor_list[i]</span><br><span class="line">        print(‘%d: %s’ % (i + <span class="number">1</span>, flavor))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 也可以通过指定 索引开始的下标序号来简化代码</span></span><br><span class="line"><span class="keyword">for</span> i, flavor <span class="keyword">in</span> enumerate(flavor_list,<span class="number">1</span>):</span><br><span class="line">    print(<span class="string">"%d: %s"</span>%(i,flavor))</span><br></pre></td></tr></table></figure>
<h3 id="第11条：用-zip-函数来同时遍历两个迭代器"><a href="#第11条：用-zip-函数来同时遍历两个迭代器" class="headerlink" title="第11条：用 zip 函数来同时遍历两个迭代器"></a>第11条：用 zip 函数来同时遍历两个迭代器</h3><h4 id="备忘录-2"><a href="#备忘录-2" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>内置的<code>zip</code>函数可以并行的对多个迭代器进行处理。</li>
<li>在<code>Python3</code>中，<code>zip</code> 采用懒模式生成器获得的是元组；而在<code>Python2</code>中，<code>zip</code>返回的是一个包含了其处理好的所有元祖的一个集合。</li>
<li>如果所处理的迭代器的长度不一致时，<code>zip</code>会默认截断输出，使得长度为最先到达尾部的那个长度。</li>
<li>内置模块<code>itertools</code>中的<code>zip_longest</code>函数可以并行地处理多个迭代器，而可以无视长度不一致的问题。</li>
</ul>
<p>Prefer:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求最长字符串</span></span><br><span class="line">names = [‘Cecilia’, ‘Lise’, ‘Marie’]</span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line">letters = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> zip(names, letters):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br><span class="line">        </span><br><span class="line">print(longest_name)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Cecilia</span><br></pre></td></tr></table></figure>
<p>not:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(names):</span><br><span class="line">	count = letters[i]</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br></pre></td></tr></table></figure>
<h3 id="第12条-在for-和while-循环体后避免使用else语句块"><a href="#第12条-在for-和while-循环体后避免使用else语句块" class="headerlink" title="第12条: 在for 和while 循环体后避免使用else语句块"></a>第12条: 在for 和while 循环体后避免使用else语句块</h3><h4 id="备忘录-3"><a href="#备忘录-3" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li><code>Python</code>有用特殊的语法能够让<code>else</code>语块在循环体结束的时候立刻得到执行。</li>
<li>循环体后的<code>else</code>语块只有在循环体没有触发<code>break</code>语句的时候才会执行。</li>
<li>避免在循环体的后面使用<code>else</code>语块，因为这样的表达不直观，而且容易误导读者。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    print(<span class="string">'Loop %d'</span> % i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Else block'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Loop <span class="number">0</span></span><br><span class="line">Loop <span class="number">1</span></span><br><span class="line">Loop <span class="number">2</span></span><br><span class="line">Else block</span><br></pre></td></tr></table></figure>
<h3 id="第13条-合理利用-try-except-else-finally"><a href="#第13条-合理利用-try-except-else-finally" class="headerlink" title="第13条: 合理利用 try/except/else/finally"></a>第13条: 合理利用 try/except/else/finally</h3><h4 id="备忘录-4"><a href="#备忘录-4" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li><code>try/finally</code>组合语句可以使得你的代码变得很整洁而无视<code>try</code>块中是否发生异常。</li>
<li><code>else</code>块可以最大限度的减少<code>try</code>块中的代码的长度，并且可以可视化地辨别<code>try/except</code>成功运行的部分。</li>
<li><code>else</code>块经常会被用于在<code>try</code>块成功运行后添加额外的行为，但是要确保代码会在<code>finally</code>块之前得到运行。\</li>
</ul>
<ol>
<li><p>finally 块</p>
<p>总是会执行，可以用来关闭文件句柄之类的</p>
</li>
<li><p>else 块</p>
<p>try 块没有发生异常则执行 else 块，有了 else 块，我们可以尽量减少 try 块的代码量</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UNDEFINED = object()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide_json</span><span class="params">(path)</span>:</span></span><br><span class="line">    handle = open(path, <span class="string">'r+'</span>) <span class="comment"># May raise IOError</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = handle.read() <span class="comment"># May raise UnicodeDecodeError</span></span><br><span class="line">        op = json.loads(data) <span class="comment"># May raise ValueError</span></span><br><span class="line">        value = (op[<span class="string">'numerator'</span>] / op[<span class="string">'denominator'</span>]) <span class="comment"># May raise ZeroDivisionError</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> UNDEFINED</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        op[‘result’] = value</span><br><span class="line">        result = json.dumps(op)</span><br><span class="line">        handle.seek(<span class="number">0</span>)</span><br><span class="line">        handle.write(result) <span class="comment"># May raise IOError</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        handle.close() <span class="comment"># Always runs</span></span><br></pre></td></tr></table></figure>
<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="第14条-返回-exceptions-而不是-None"><a href="#第14条-返回-exceptions-而不是-None" class="headerlink" title="第14条: 返回 exceptions 而不是 None"></a>第14条: 返回 exceptions 而不是 None</h3><h4 id="备忘录-5"><a href="#备忘录-5" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>返回<code>None</code>的函数来作为特殊的含义是容易出错的，因为<code>None</code>和其他的变量（例如 <code>zero</code>，空字符串）在条件表达式的判断情景下是等价的。</li>
<li>通过触发一个异常而不是直接的返回<code>None</code>是比较常用的一个方法。这样调用方就能够合理地按照函数中的说明文档来处理由此而引发的异常了。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a / b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>返回 None 容易造成误用，下面的程式分不出 0 和 None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, y = <span class="number">0</span>, <span class="number">5</span></span><br><span class="line">result = divide(x, y)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">    print(<span class="string">'Invalid inputs'</span>)  <span class="comment"># This is wrong!</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>raise exception:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> a / b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Invalid inputs'</span>) <span class="keyword">from</span> e</span><br></pre></td></tr></table></figure>
<p>调用者看到该函数的文档中描述的异常之后，应该就会编写相应的代码来处理它们了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, y = <span class="number">5</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = divide(x, y)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">"Invalid inputs"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Result is %.1f"</span>% result)</span><br><span class="line"> &gt;&gt;&gt;</span><br><span class="line"> Result <span class="keyword">is</span> <span class="number">2.5</span></span><br></pre></td></tr></table></figure>
<h3 id="第15条-了解闭包中是怎样使用外围作用域变量"><a href="#第15条-了解闭包中是怎样使用外围作用域变量" class="headerlink" title="第15条: 了解闭包中是怎样使用外围作用域变量"></a>第15条: 了解闭包中是怎样使用外围作用域变量</h3><h4 id="备忘录-6"><a href="#备忘录-6" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>闭包函数可以从变量被定义的作用域内引用变量。</li>
<li>默认地，闭包不能通过赋值来影响其检索域。</li>
<li>在<code>Python3</code>中，可以使用<code>nonlocal</code>关键字来突破闭包的限制，进而在其检索域内改变其值。(<code>global</code> 关键字用于使用全局变量，<code>nonlocal</code> 关键字用于使用局部变量(函数内))</li>
<li><code>Python2</code>中没有<code>nonlocal</code>关键字，替代方案就是使用一个单元素（如列表，字典，集合等等）来实现与<code>nonlocal</code>一致的功能。</li>
<li>除了简单的函数，在其他任何地方都应该尽力的避免使用<code>nonlocal</code>关键字。</li>
</ul>
<p>Python编译器变量查找域的顺序：</p>
<ul>
<li>当前函数的作用域</li>
<li>任何其他的封闭域（比如其他的包含着的函数）。</li>
<li>包含该段代码的模块域（也称之为全局域）</li>
<li>内置域（包含了像<code>len</code>,<code>str</code>等函数的域）</li>
</ul>
<p>考虑如下示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 优先排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, group)</span>:</span></span><br><span class="line">    found = <span class="keyword">False</span>    <span class="comment"># 作用域：sort_priority2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="keyword">True</span>      <span class="comment"># 作用域： helper</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, x)   <span class="comment"># found在helper的作用域就会由helper转至sort_priority2函数</span></span><br><span class="line">    </span><br><span class="line">    values.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">values = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">group = [<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="comment"># begin to call</span></span><br><span class="line">found = sort_priority2(values, group)</span><br><span class="line">print(<span class="string">"Found:"</span>,found)</span><br><span class="line">print(values)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Found: <span class="keyword">False</span></span><br><span class="line">[<span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>排序的结果是正确的，但是很明显分组的那个标志是不正确的了。<code>group</code>中的元素无疑可以在<code>values</code>里面找到，但是函数却返回了<code>False</code>，为什么会发生这样的状况呢？（提示：Python 编译器变量查找域的顺序）</p>
<h4 id="把数据放到外边"><a href="#把数据放到外边" class="headerlink" title="把数据放到外边"></a>把数据放到外边</h4><p>在<code>Python3</code>中，对于闭包而言有一个把数据放到外边的特殊的语法。<code>nonlocal</code>语句习惯于用来表示一个特定变量名称的域的遍历发生在赋值之前。 唯一的限制就是<code>nonlocal</code>不会向上遍历到模块域级别（这也是为了防止污染全局变量空间）。这里，我定义了一个使用了<code>nonlocal</code>关键字的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">srt_priority3</span><span class="params">(numbers, group)</span>:</span></span><br><span class="line">    found = <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> found </span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, x)</span><br><span class="line">    numbers.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>
<p>当数据在闭包外将被赋值到另一个域时，<code>nonlocal</code> 语句使得这个过程变得很清晰。它也是对<code>global</code>语句的一个补充，可以明确的表明变量的赋值应该被直接放置到模块域中。</p>
<p>然而，像这样的反模式，对使用在那些简单函数之外的其他的任何地方。<code>nonlocal</code>引起的副作用是难以追踪的，而在那些包含着<code>nonlocal</code>语句和赋值语句交叉联系的大段代码的函数的内部则尤为明显。</p>
<p>当你感觉自己的<code>nonlocal</code>语句开始变的复杂的时候，我非常建议你重构一下代码，写成一个工具类。这里，我定义了一个实现了与上面的那个函数功能相一致的工具类。虽然有点长，但是代码却变得更加的清晰了（详见第23项：对于简单接口使用函数而不是类里面的<code>__call__</code>方法）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group)</span>:</span></span><br><span class="line">        self.group = group</span><br><span class="line">        self.found = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> self.group:</span><br><span class="line">            self.found = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, x)</span><br><span class="line"></span><br><span class="line">sorter = Sorter(group)</span><br><span class="line">numbers.sort(key=sorter)</span><br><span class="line"><span class="keyword">assert</span> sorter <span class="keyword">is</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h4 id="Python2中的作用域"><a href="#Python2中的作用域" class="headerlink" title="Python2中的作用域"></a>Python2中的作用域</h4><p>不幸的是，<code>Python2</code>是不支持<code>nonlocal</code>关键字的。为了实现相似的功能，你需要广泛的借助于<code>Python</code>的作用与域规则。虽然这个方法并不是完美的，但是这是<code>Python</code>中比较常用的一种做法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority</span><span class="params">(numbers, group)</span>:</span></span><br><span class="line">    found = [<span class="keyword">False</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, x)</span><br><span class="line">    numbers.sort(sort=helper)</span><br><span class="line">    <span class="keyword">return</span> found[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>就像上面解释的那样，<code>Python</code> 将会横向查找该变量所在的域来分析其当前值。技巧就是发现的值是一个易变的列表。这意味着一旦检索，闭包就可以修改<code>found</code>的状态值，并且把内部数据的改变发送到外部，这也就打破了闭包引发的局部变量作用域无法被改变的难题。其根本还是在于列表本身元素值可以被改变，这才是此函数可以正常工作的关键。</p>
<p>当<code>found</code>为一个<code>dictionary</code>类型的时候，也是可以正常工作的，原理与上文所言一致。此外，<code>found</code>还可以是一个集合，一个你自定义的类等等。</p>
<h3 id="第16条-考虑使用生成器而不是返回列表"><a href="#第16条-考虑使用生成器而不是返回列表" class="headerlink" title="第16条: 考虑使用生成器而不是返回列表"></a>第16条: 考虑使用生成器而不是返回列表</h3><h4 id="备忘录-7"><a href="#备忘录-7" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>相较于返回一个列表的情况，替代方案中使用生成器可以使得代码变得更加的清晰。</li>
<li>生成器返回的迭代器，是在其生成器内部一个把值传递给了<code>yield</code>变量的集合。</li>
<li>生成器可以处理很大的输出序列就是因为它在处理的时候不会完全的包含所有的数据。</li>
</ul>
<p>考虑以下两种版本代码，一个用 <strong>list </strong>，另一个用 <strong>generator</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span><span class="params">(text)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">            result.append(index + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">address = <span class="string">'Four score and seven years ago...'</span></span><br><span class="line">result = index_words(address)</span><br><span class="line">print(result[:<span class="number">3</span>]) <span class="comment"># [0, 5, 11]</span></span><br></pre></td></tr></table></figure>
<p>generator</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words_iter</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">yield</span> index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">result = list(index_words_iter(address))</span><br></pre></td></tr></table></figure>
<p>使用 <strong>generator </strong> 比较简单，减少了 list 操作</p>
<p>另一个 <strong>generator </strong>的好处是更有效率地使用记忆值，generator不需要有存全部的资料</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_file</span><span class="params">(handle)</span>:</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> handle:</span><br><span class="line">        <span class="keyword">if</span> line:</span><br><span class="line">            <span class="keyword">yield</span> offset</span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> line:</span><br><span class="line">            offset += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> letter == <span class="string">' '</span>:</span><br><span class="line">                <span class="keyword">yield</span> offset</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/address.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    it = index_file(f)</span><br><span class="line">    results = itertools.islice(it, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">    print(list(results))</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>
<p>不管address.txt 多大都能处理</p>
<h3 id="第17条-遍历参数的时候小心一点"><a href="#第17条-遍历参数的时候小心一点" class="headerlink" title="第17条: 遍历参数的时候小心一点"></a>第17条: 遍历参数的时候小心一点</h3><h4 id="备忘录-8"><a href="#备忘录-8" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>多次遍历输入参数的时候应该多加小心。如果参数是迭代器的话你可能看到奇怪的现象或者缺少值现象的发生。</li>
<li><code>Python</code>的<code>iterator</code>协议定义了容器和迭代器在<code>iter</code>和<code>next</code>下对于循环和相关表达式的关系。</li>
<li>只要实现了<code>__iter__</code>方法，你就可以很容易的定义一个可迭代的容器类。</li>
<li>通过连续调用两次<code>iter</code>方法，你就可以预先检测一个值是不是迭代器而不是容器。两次结果一致那就是迭代器，否则就是容器了。</li>
</ul>
<p>generator不能重用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_visits</span><span class="params">(data_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(data_path,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">yield</span> int(line)</span><br><span class="line"></span><br><span class="line">it = read_visits(<span class="string">'tmp/my_numbers.txt'</span>)</span><br><span class="line">print(list(it))</span><br><span class="line">print(list(it)) <span class="comment"># 这里其实已经执行到头了</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">15</span>, <span class="number">35</span>, <span class="number">80</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>造成上述结果的原因是 一个迭代器每次只处理它本身的数据。如果你遍历一个迭代器或者生成器本身已经引发了一个<code>StopIteration</code>的异常，你就不可能获得任何数据了。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>每次调用都创建iterator避免上面list分配内存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize_func</span><span class="params">(get_iter)</span>:</span>  <span class="comment"># get_iter 是函数</span></span><br><span class="line">    total = sum(get_iter())    <span class="comment"># New iterator</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> get_iter():   <span class="comment"># New iterator</span></span><br><span class="line">       percent = <span class="number">100</span> * value / total</span><br><span class="line">       result.append(percent)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">percentages = normalize_func(<span class="keyword">lambda</span>: read_visits(path))</span><br></pre></td></tr></table></figure>
<p>for循环会调用内置iter函数，进而调用对象的__iter__方法，__iter__会返回iterator对象（实现__next__方法）</p>
<p>用iter函数检测iterator：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize_defensive</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> iter(numbers) <span class="keyword">is</span> iter(numbers): <span class="comment"># 是个迭代器，这样不好</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'Must supply a container'</span>)</span><br><span class="line">    total = sum(numbers)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> numbers:</span><br><span class="line">        percent = <span class="number">100</span> * value / total</span><br><span class="line">        result.append(percent)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">visits = [<span class="number">15</span>, <span class="number">35</span>, <span class="number">80</span>]</span><br><span class="line">normalize_defensive(visits)</span><br><span class="line">visits = ReadVIsitors(path)</span><br><span class="line">normalize_defensive(visits)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是如果输入值不是一个容器类的话，就会引发异常了</span></span><br><span class="line">it = iter(visits)</span><br><span class="line">normalize_defensive(it)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">TypeError: Must supply a container</span><br></pre></td></tr></table></figure>
<h3 id="第18条-减少位置参数上的干扰"><a href="#第18条-减少位置参数上的干扰" class="headerlink" title="第18条: 减少位置参数上的干扰"></a>第18条: 减少位置参数上的干扰</h3><h4 id="备忘录-9"><a href="#备忘录-9" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>通过使用<code>*args</code>定义语句，函数可以接收可变数量的位置参数。</li>
<li>你可以通过<code>*</code>操作符来将序列中的元素作为位置变量。</li>
<li>带有<code>*</code>操作符的生成器变量可能会引起程序的内存溢出，或者机器宕机。</li>
<li>为可以接受<code>*args</code>的函数添加新的位置参数可以产生难于发现的问题，应该谨慎使用。</li>
</ul>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message, values)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">        print(message)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values_str = <span class="string">', '</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">        print(<span class="string">'%s: %s'</span> % (message, values_str))</span><br><span class="line"></span><br><span class="line">log(<span class="string">'My numbers are'</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">log(<span class="string">'Hi there'</span>, [])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message, *values)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">        print(message)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values_str = <span class="string">', '</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">        print(<span class="string">'%s: %s'</span> % (message, values_str))</span><br><span class="line"></span><br><span class="line">log(<span class="string">'My numbers are'</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">log(<span class="string">'Hi there'</span>)</span><br></pre></td></tr></table></figure>
<p>第二个就比第一个要更有弹性</p>
<p>不过传入生成器的时候，因为变长参数在传给函数的时候，总要先转换为元组，所以如果生成器迭代的数据很大的话，可能会导致程序崩溃</p>
<h3 id="第19条-使用关键字参数来提供可选行为"><a href="#第19条-使用关键字参数来提供可选行为" class="headerlink" title="第19条: 使用关键字参数来提供可选行为"></a>第19条: 使用关键字参数来提供可选行为</h3><h4 id="备忘录-10"><a href="#备忘录-10" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>函数的参数值即可以通过位置被指定，也可以通过关键字来指定。</li>
<li>相较于使用位置参数赋值，使用关键字来赋值会让你的赋值语句逻辑变得更加的清晰。</li>
<li>带有默认参数的关键字参数函数可以很容易的添加新的行为，尤其适合向后兼容。</li>
<li>可选的关键字参数应该优于位置参数被考虑使用。</li>
</ul>
<p>关键字参数的好处:</p>
<ol>
<li>代码可读性的提高</li>
<li>以在定义的时候初始化一个默认值</li>
<li>在前面的调用方式不变的情况下可以很好的拓展函数的参数，不用修改太多的代码</li>
</ol>
<p>如果本來的函数如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flow_rate</span><span class="params">(weight_diff, time_diff, period=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (weight_diff / time_diff) * period</span><br></pre></td></tr></table></figure>
<p>如果后来函数修改了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flow_rate</span><span class="params">(weight_diff, time_diff,</span></span></span><br><span class="line"><span class="function"><span class="params">              period=<span class="number">1</span>, units_per_kg=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ((weight_diff / units_per_kg) / time_diff) * period</span><br></pre></td></tr></table></figure>
<p>那么可以如下使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flow_per_second = flow_rate(weight_diff, time_diff)</span><br><span class="line">flow_per_hour = flow_rate(weight_diff, time_diff, period=<span class="number">3600</span>)</span><br><span class="line">pounds_per_hour = flow_rate(weight_diff, time_diff, period=<span class="number">3600</span>, units_per_kg=<span class="number">2.2</span>)</span><br><span class="line">pounds_per_hour = flow_rate(weight_diff, time_diff, <span class="number">3600</span>, <span class="number">2.2</span>) <span class="comment"># 不推荐</span></span><br></pre></td></tr></table></figure>
<h3 id="第20条-使用None和文档说明动态的指定默认参数"><a href="#第20条-使用None和文档说明动态的指定默认参数" class="headerlink" title="第20条: 使用None和文档说明动态的指定默认参数"></a>第20条: 使用None和文档说明动态的指定默认参数</h3><h4 id="备忘录-11"><a href="#备忘录-11" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>默认参数只会被赋值一次：在其所在模块被加载的过程中,这有可能导致一些奇怪的现象。</li>
<li>使用<code>None</code>作为关键字参数的默认值会有一个动态值。要在该函数的说明文档中详细的记录一下。</li>
</ul>
<h4 id="第一个例子：-1"><a href="#第一个例子：-1" class="headerlink" title="第一个例子："></a>第一个例子：</h4><p>not:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message, when=datetime.now<span class="params">()</span>)</span>:</span></span><br><span class="line">    print(‘%s: %s’ % (when, message))</span><br><span class="line">    </span><br><span class="line">log(‘Hi there!’)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">log(‘Hi again!’)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-15</span> <span class="number">21</span>:<span class="number">10</span>:<span class="number">10.371432</span>: Hi there!</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-15</span> <span class="number">21</span>:<span class="number">10</span>:<span class="number">10.371432</span>: Hi again!</span><br></pre></td></tr></table></figure>
<p>prefer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message, when=None)</span>:</span></span><br><span class="line">    <span class="string">"""Log a message with a timestamp.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        message: Message to print</span></span><br><span class="line"><span class="string">        when: datetime of when the message occurred.</span></span><br><span class="line"><span class="string">            Default to the present time.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    when = datetime.now() <span class="keyword">if</span> when <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> when</span><br><span class="line">    print(<span class="string">"%s: %s"</span> %(when, message))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hi there!'</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">log(<span class="string">'Hi again!'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-15</span> <span class="number">21</span>:<span class="number">10</span>:<span class="number">10.472303</span>: Hi there!</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-15</span> <span class="number">21</span>:<span class="number">10</span>:<span class="number">10.473395</span>: Hi again!</span><br></pre></td></tr></table></figure>
<p>上述方法造成 when 第一次被赋值之后便不会再重新赋值</p>
<h4 id="第二个例子：-1"><a href="#第二个例子：-1" class="headerlink" title="第二个例子："></a>第二个例子：</h4><p>not:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(data, default=&#123;&#125;)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">foo = decode(<span class="string">'bad data'</span>)</span><br><span class="line">foo[<span class="string">'stuff'</span>] = <span class="number">5</span></span><br><span class="line">bar = decode(<span class="string">'also bad'</span>)</span><br><span class="line">bar[<span class="string">'meep'</span>] = <span class="number">1</span></span><br><span class="line">print(<span class="string">'Foo:'</span>, foo)</span><br><span class="line">print(<span class="string">'Bar:'</span>, bar)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Foo: &#123;<span class="string">'stuff'</span>: <span class="number">5</span>, <span class="string">'meep'</span>: <span class="number">1</span>&#125;</span><br><span class="line">Bar: &#123;<span class="string">'stuff'</span>: <span class="number">5</span>, <span class="string">'meep'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>prefer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(data, default=None)</span>:</span></span><br><span class="line">    <span class="string">"""Load JSON data from string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        data: JSON data to be decoded.</span></span><br><span class="line"><span class="string">        default: Value to return if decoding fails.</span></span><br><span class="line"><span class="string">            Defaults to an empty dictionary.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> default <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        default = &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在测试一下</span></span><br><span class="line">foo = decode(<span class="string">'bad data'</span>)</span><br><span class="line">foo[<span class="string">'stuff'</span>] = <span class="number">5</span></span><br><span class="line">bar = decode(<span class="string">'also bad'</span>)</span><br><span class="line">bar[<span class="string">'meep'</span>] = <span class="number">1</span></span><br><span class="line">print(<span class="string">'Foo:'</span>, foo)</span><br><span class="line">print(<span class="string">'Bar:'</span>, bar)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Foo: &#123;<span class="string">'stuff'</span>: <span class="number">5</span>&#125;</span><br><span class="line">Bar: &#123;<span class="string">'meep'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第21条-仅强调关键字参数"><a href="#第21条-仅强调关键字参数" class="headerlink" title="第21条: 仅强调关键字参数"></a>第21条: 仅强调关键字参数</h3><h4 id="备忘录-12"><a href="#备忘录-12" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>关键字参数使得函数调用的意图更加的清晰，明显。</li>
<li>使用<code>keyword-only</code>参数可以强迫函数调用者提供关键字来赋值，这样对于容易使人疑惑的函数参数很有效，尤其适用于接收多个布尔变量的情况。</li>
<li><code>Python3</code>中有明确的<code>keyword-only</code>函数语法。</li>
<li><code>Python2</code>中可以通过<code>**kwargs</code>模拟实现<code>keyword-only</code>函数语法,并且人工的触发<code>TypeError</code>异常。</li>
<li><code>keyword-only</code>在函数参数列表中的位置很重要，这点大家尤其应该明白！</li>
</ul>
<p>下面的程式使用上不方便，因为容易忘记 ignore_overflow 和 ignore_zero_division 的顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division</span><span class="params">(number, divisor, ignore_overflow,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ignore_zero_division)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> number / divisor</span><br><span class="line">    <span class="keyword">except</span> OverflowError:</span><br><span class="line">        <span class="keyword">if</span> ignore_overflow:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">if</span> ignore_zero_division:</span><br><span class="line">            <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">result = safe_division(<span class="number">1</span>, <span class="number">10</span>**<span class="number">500</span>, <span class="keyword">True</span>, <span class="keyword">False</span>)</span><br><span class="line">result = safe_division(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">False</span>, <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>用 keyword 引数可解決此问题，在 Python 3 可以宣告强制接收 keyword-only 参数。</p>
<p>下面定义的这个 safe_division_c 函数，带有两个只能以关键字形式来指定的参数。参数列表里面的 * 号，标志着位置参数就此终结，之后的那些参数，都只能以关键字的形式来指定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division_c</span><span class="params">(number, divisor, *,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ignore_overflow=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ignore_zero_division=False)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> number / divisor</span><br><span class="line">    <span class="keyword">except</span> OverflowError:</span><br><span class="line">        <span class="keyword">if</span> ignore_overflow:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="keyword">if</span> ignore_zero_division:</span><br><span class="line">            <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">safe_division_c(<span class="number">1</span>, <span class="number">10</span>**<span class="number">500</span>, <span class="keyword">True</span>, <span class="keyword">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line">TypeError: safe_division_c() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</span><br><span class="line"></span><br><span class="line">safe_division(<span class="number">1</span>, <span class="number">0</span>, ignore_zero_division=<span class="keyword">True</span>)  <span class="comment"># OK</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Python 2 虽然没有这种语法，但可以用 <code>**</code> 操作符模拟</p>
<p>注：<code>*</code> 操作符接收可变数量的位置参数，<code>**</code> 接受任意数量的关键字参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division</span><span class="params">(number, divisor, **kwargs)</span>:</span></span><br><span class="line">    ignore_overflow = kwargs.pop(<span class="string">'ignore_overflow'</span>, <span class="keyword">False</span>)</span><br><span class="line">    ignore_zero_division = kwargs.pop(<span class="string">'ignore_zero_division'</span>, <span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">if</span> kwargs:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"Unexpected **kwargs: %r"</span>%kwargs)</span><br><span class="line">    <span class="comment"># ···</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">safe_division(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">safe_division(<span class="number">1</span>, <span class="number">0</span>, ignore_zero_division=<span class="keyword">True</span>)</span><br><span class="line">safe_division(<span class="number">1</span>, <span class="number">10</span>**<span class="number">500</span>, ignore_overflow=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 而想通过位置参数赋值，就不会正常的运行了</span></span><br><span class="line">safe_division(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">False</span>, <span class="keyword">True</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">TypeError：safe_division() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given.</span><br></pre></td></tr></table></figure>
<h2 id="三、类和继承"><a href="#三、类和继承" class="headerlink" title="三、类和继承"></a>三、类和继承</h2><h3 id="第22条-尽量使用辅助类来维护程序的状态，避免dict嵌套dict或大tuple"><a href="#第22条-尽量使用辅助类来维护程序的状态，避免dict嵌套dict或大tuple" class="headerlink" title="第22条: 尽量使用辅助类来维护程序的状态，避免dict嵌套dict或大tuple"></a>第22条: 尽量使用辅助类来维护程序的状态，避免dict嵌套dict或大tuple</h3><h4 id="备忘录-13"><a href="#备忘录-13" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>避免字典中嵌套字典，或者长度较大的元组。</li>
<li>在一个整类（类似于前面第一个复杂类那样）之前考虑使用 <code>namedtuple</code> 制作轻量，不易发生变化的容器。</li>
<li>当内部的字典关系变得复杂的时候将代码重构到多个工具类中。</li>
</ul>
<p>dictionaries 以及 tuples 拿來存简单的资料很方便，但是当资料越来越复杂时，例如多层 dictionaries 或是 n-tuples，程式的可读性就下降了。例如下面的程式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleGradebook</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._grades = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_student</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self._grades[name] = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">report_grade</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self._grades[name].append(score)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average_grade</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        grades = self._grades[name]</span><br><span class="line">        <span class="keyword">return</span> sum(grades) / len(grades)</span><br></pre></td></tr></table></figure>
<p>正是由于字典很容易被使用，以至于对字典过度的拓展会导致代码越来越脆弱。例如：你想拓展一下<code>SimpleGradebook</code>类来根据科目保存成绩的学生的集合,而不再是整体性的存储。你就可以通过修改<code>_grade</code>字典来匹配学生姓名，使用另一个字典来包含成绩。而最里面的这个字典将匹配科目（<code>keys</code>)和成绩(<code>values</code>)。你还想根据班级内总体的成绩来追踪每个门类分数所占的比重，所以期中，期末考试相比于平时的测验而言更为重要。实现这个功能的一个方式是改变最内部的那个字典，而不是让其关联着科目（<code>key</code>)和成绩（<code>values</code>)。我们可以使用元组（<code>tuple</code>)来作为成绩（<code>values</code>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightedGradebook</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._grades = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_student</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self._grades[name] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">report_grade</span><span class="params">(self, name, subject, score, weight)</span>:</span></span><br><span class="line">        by_subject = self._grades[name]</span><br><span class="line">        grade_list = by_subject.setdefault(subject, [])</span><br><span class="line">        grade_list.append((score, weight))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average_grade</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        by_subject = self._grades[name]</span><br><span class="line">        score_sum, score_count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> subject, scores <span class="keyword">in</span> by_subject.items():</span><br><span class="line">            subject_avg, total_weight = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> score, weight <span class="keyword">in</span> scores:</span><br><span class="line">                subject_avg += score * weight</span><br><span class="line">                total_weight += weight</span><br><span class="line">            score_sum += subject_avg / total_weight</span><br><span class="line">            score_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> score_sum / score_count</span><br></pre></td></tr></table></figure>
<p>这个类使用起来貌似也变的超级复杂了，并且每个位置参数代表了什么意思也不明不白的。</p>
<h4 id="重构成多个类"><a href="#重构成多个类" class="headerlink" title="重构成多个类"></a>重构成多个类</h4><p>你可以从依赖树的底端开始，将其划分成多个类：一个单独的成绩类好像对于如此一个简单的信息权重太大了。一个元组，使用元组似乎很合适，因为成绩是不会改变的了，这刚好符合元组的特性。这里，我使用一个元组（<code>score</code>, <code>weight</code>)来追踪列表中的成绩信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Grade = collections.namedtuple(<span class="string">'Grade'</span>, (<span class="string">'score'</span>, <span class="string">'weight'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._grades = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">report_grade</span><span class="params">(self, score, weight)</span>:</span></span><br><span class="line">        self._grades.append(Grade(score, weight))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        total, total_weight = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> grade <span class="keyword">in</span> self._grades:</span><br><span class="line">            total += grade.score * grade.weight</span><br><span class="line">            total_weight += grade.weight</span><br><span class="line">        <span class="keyword">return</span> total / total_weight</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._subjects = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subject</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> self._subjects:</span><br><span class="line">            self._subjects[name] = Subject()</span><br><span class="line">        <span class="keyword">return</span> self._subjects[name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        total, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> subject <span class="keyword">in</span> self._subjects.values():</span><br><span class="line">            total += subject.average_grade()</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gradebook</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._students = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">student</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> self._students:</span><br><span class="line">            self._students[name] = Student()</span><br><span class="line">        <span class="keyword">return</span> self._students[name]</span><br></pre></td></tr></table></figure>
<h3 id="第23条-对于简单接口使用函数而不是类的实例"><a href="#第23条-对于简单接口使用函数而不是类的实例" class="headerlink" title="第23条: 对于简单接口使用函数而不是类的实例"></a>第23条: 对于简单接口使用函数而不是类的实例</h3><h4 id="备忘录-14"><a href="#备忘录-14" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>在<code>Python</code>中，不需要定义或实现什么类，对于简单接口组件而言，函数就足够了。</li>
<li><code>Python</code>中引用函数和方法的原因就在于它们是<code>first-class</code>，可以直接的被运用在表达式中。</li>
<li>特殊方法<code>__call__</code>允许你像调用函数一样调用一个对象实例。</li>
<li>当你需要一个函数来维护状态信息的时候，考虑一个定义了<code>__call__</code>方法的状态闭包类哦（详见第<code>15</code>项：了解闭包是怎样与变量作用域的联系）。</li>
</ul>
<p><code>Python</code>中的许多内置的<code>API</code>都允许你通过向函数传递参数来自定义行为。这些被<code>API</code>使用的<code>hooks</code>将会在它们运行的时候回调给你的代码。例如：<code>list</code>类型的排序方法中有一个可选的<code>key</code> 参数来决定排序过程中每个下标的值。这里，我使用一个<code>lambda</code>表达式作为这个键钩子，根据名字中字符的长度来为这个集合排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'Socrates'</span>, <span class="string">'Archimedes'</span>, <span class="string">'Plato'</span>, <span class="string">'Aristotle'</span>]</span><br><span class="line">names.sort(key=<span class="keyword">lambda</span> x: len(x))</span><br><span class="line">print(names)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">'Plato'</span>, Socrates<span class="string">', '</span>Aristotle<span class="string">', '</span>Archimedes<span class="string">']</span></span><br></pre></td></tr></table></figure>
<p>在其他的编程语言中，你可能期望一个抽象类作为这个<code>hooks</code>。但是在<code>Python</code>中，许多的<code>hooks</code>都是些无状态的有良好定义参数和返回值的函数。而对于<code>hooks</code>而言，使用函数是很理想的。因为更容易藐视，相对于类而言定义起来也更加的简单。函数可以作为钩子来工作是因为<code>Python</code>有<code>first-class</code>函数：在编程的时候函数，方法可以像其他的变量值一样被引用，或者被传递给其他的函数。</p>
<p><code>Python</code>允许类来定义<code>__call__</code>这个特殊的方法。它允许一个对象像被函数一样来被调用。这样的一个实例也引起了<code>callable</code>这个内<code>True</code>的事实。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">current = &#123;<span class="string">'green'</span>: <span class="number">12</span>, <span class="string">'blue'</span>: <span class="number">3</span>&#125;</span><br><span class="line">incremetns = [</span><br><span class="line">    (<span class="string">'red'</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="string">'blue'</span>, <span class="number">17</span>),</span><br><span class="line">    (<span class="string">'orange'</span>, <span class="number">9</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterCountMissing</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.added = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.added += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">counter = BetterCountMissing()</span><br><span class="line">counter()</span><br><span class="line"><span class="keyword">assert</span> callable(counter)</span><br><span class="line"><span class="comment"># 这里我使用一个BetterCountMissing实例作为defaultdict函数的默认的hook值来追踪缺省值被添加的次数。</span></span><br><span class="line">counter = BetterCountMissing()</span><br><span class="line">result = defaultdict(counter, current)</span><br><span class="line"><span class="keyword">for</span> key, amount <span class="keyword">in</span> increments:</span><br><span class="line">    result[key] += amount</span><br><span class="line"><span class="keyword">assert</span> counter.added == <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="第24条-使用-classmethod多态性构造对象"><a href="#第24条-使用-classmethod多态性构造对象" class="headerlink" title="第24条: 使用@classmethod多态性构造对象"></a>第24条: 使用@classmethod多态性构造对象</h3><h4 id="备忘录-15"><a href="#备忘录-15" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li><code>Python</code>的每个类只支持单个的构造方法，<code>__init__</code>。</li>
<li>使用<code>@classmethod</code>可以为你的类定义可替代构造方法的方法。</li>
<li>类的多态为具体子类的组合提供了一种更加通用的方式。</li>
</ul>
<p>使用 <code>@classmethod</code>起到多态的效果：一个对于分层良好的类树中，不同类之间相同名称的方法却实现了不同的功能的体现。</p>
<p>下面的函数 generate_inputs() 不够一般化，只能使用 PathInputData ，如果想使用其它 InputData 的子类，必须改变函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputData</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathInputData</span><span class="params">(InputData)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> open(self.path).read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_inputs</span><span class="params">(data_dir)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(data_dir):</span><br><span class="line">        <span class="keyword">yield</span> PathInputData(os.path.join(data_dir, name))</span><br></pre></td></tr></table></figure>
<p>问题在于建立 <code>InputData</code> 子类的物件不够一般化，如果你想要编写另一个 <code>InputData</code> 的子类就必须重写 <code>read</code> 方法幸好有 <code>@classmethod</code>，可以达到一样的效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericInputData</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_inputs</span><span class="params">(cls, config)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathInputData</span><span class="params">(GenericInputData)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> open(self.path).read()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_inputs</span><span class="params">(cls, config)</span>:</span></span><br><span class="line">        data_dir = config[<span class="string">'data_dir'</span>]</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(data_dir):</span><br><span class="line">            <span class="keyword">yield</span> cls(os.path.join(data_dir, name))</span><br></pre></td></tr></table></figure>
<h3 id="第25条-使用super关键字初始化父类"><a href="#第25条-使用super关键字初始化父类" class="headerlink" title="第25条: 使用super关键字初始化父类"></a>第25条: 使用super关键字初始化父类</h3><h4 id="备忘录-16"><a href="#备忘录-16" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li><code>Python</code>的解决实例化次序问题的方法<code>MRO</code>解决了菱形继承中超类多次被初始化的问题。</li>
<li>总是应该使用<code>super</code>来初始化父类。</li>
</ul>
<p>先看一个还行的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesTwo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.value *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusFive</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.value += <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多继承实例,注意继承的次序哦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneWay</span><span class="params">(MyBaseClass, TimesTwo, PlusFive)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        MyBaseClass.__init__(self, value)</span><br><span class="line">        TimesTwo.__init__(self)</span><br><span class="line">        PlusFive.__init__(self)</span><br><span class="line"></span><br><span class="line">foo = OneWay(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">"First ordering is ( 5 * 2 ) + 5 = "</span>, foo.value)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">First ordering <span class="keyword">is</span> (<span class="number">5</span> * <span class="number">2</span> ) + <span class="number">2</span> = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>不使用 <strong>super() </strong>在多重继承时可能会造成意想不到的问题，下面的程式造成所谓的 <strong>diamond inheritance </strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesFive</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        MyBaseClass.__init__(self, value)</span><br><span class="line">        self.value *= <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusTwo</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        MyBaseClass.__init__(self, value)</span><br><span class="line">        self.value += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisWay</span><span class="params">(TimesFive, PlusTwo)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        TimesFive.__init__(self, value)</span><br><span class="line">        PlusTwo.__init__(self, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">foo = ThisWay(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">'Should be (5 * 5) + 2 = 27 but is'</span>, foo.value)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Should be (<span class="number">5</span> * <span class="number">5</span>) + <span class="number">2</span> = <span class="number">27</span> but <span class="keyword">is</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>注：foo.value 的值是 7 ，而不是 27。因为 <code>PlusTwo.__init__(self, value)</code> 将值重设为 5 了。</p>
<p>使用 <code>super()</code>可以正确得到 27</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 现在，菱形继承的超类，也就是最顶上的那个`MyBaseClass`只会被初始化一次，而其他的两个父类会按照被声明的顺序来初始化了。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodWay</span><span class="params">(TimesFiveCorrect, PlusTwoCorrect)</span>:</span><span class="comment"># Python 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesFiveCorrect</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super(TimesFiveCorrect, self).__init__(value)</span><br><span class="line">        self.value *= <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusTwoCorrect</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super(PlusTwoCorrect, self).__init__(value)</span><br><span class="line">        self.value += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodWay</span><span class="params">(PlusTwoCorrect, TimesFiveCorrect)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super(GoodWay, self).__init__(value)</span><br><span class="line"></span><br><span class="line">foo = GoodWay(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">"Should be 5 * (5 + 2) = 35 and is "</span> , foo.value)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Should be <span class="number">5</span> * (<span class="number">5</span> + <span class="number">2</span>) = <span class="number">35</span> <span class="keyword">and</span> <span class="keyword">is</span> <span class="number">35</span></span><br></pre></td></tr></table></figure>
<p>python中父类实例化的规则是按照<code>MRO</code>标准来进行的，MRO 的执行顺序是 DFS </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 2</span></span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">pprint(GoodWay.mro())</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[&lt;class '__main__.GoodWay'&gt;,</span><br><span class="line">&lt;class '__main__.TimesFiveCorrect'&gt;,</span><br><span class="line">&lt;class '__main__.PlusTwoCorrect'&gt;,</span><br><span class="line">&lt;class '__main__.MyBaseClass'&gt;,</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">object</span>'&gt;]</span></span><br></pre></td></tr></table></figure>
<p>最开始初始化<code>GoodWay</code>的时候，程序并没有真正的执行，而是走到这条继承树的树根，从树根往下才会进行初始化。于是我们会先初始化<code>MyBaseClass</code>的<code>value</code>为<code>5</code>，然后是<code>PlusTwoCorrect</code>的<code>value</code>会变成<code>7</code>，接着<code>TimesFiveCorrect</code>的<code>value</code>就自然的变成<code>35</code>了。</p>
<p>Python 3 简化了 <strong>super() </strong>的使用方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implicit</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super().__init__(value * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="第26条-只在用编写Max-in组件的工具类的时候使用多继承"><a href="#第26条-只在用编写Max-in组件的工具类的时候使用多继承" class="headerlink" title="第26条: 只在用编写Max-in组件的工具类的时候使用多继承"></a>第26条: 只在用编写Max-in组件的工具类的时候使用多继承</h3><h4 id="备忘录-17"><a href="#备忘录-17" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>如果可以使用<code>mix-in</code>实现相同的结果输出的话，就不要使用多继承了。</li>
<li>当<code>mix-in</code>类需要的时候，在实例级别上使用可插拔的行为可以为每一个自定义的类工作的更好。</li>
<li>从简单的行为出发，创建功能更为灵活的<code>mix-in</code>。</li>
</ul>
<p>如果你发现自己渴望随继承的便利和封装,那么考虑<code>mix-in</code>吧。它是一个只定义了几个类必备功能方法的很小的类。<code>Mix-in</code>类不定义以自己的实例属性，也不需要它们的初始化方法<code>__init__</code>被调用。<code>Mix-in</code>可以被分层和组织成最小化的代码块，方便代码的重用。</p>
<p>mix-in 是可以替换的 class ，通常只定义 methods ，虽然本质上上还是通过继承的方式，但因为 mix-in 沒有自己的 state ，也就是说沒有定义 attributes ，使用上更有弹性。</p>
<p>范例1:</p>
<p>注：hasattr 函数动态访问属性，isinstance 函数动态检测对象类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToDictMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._traverse_dict(self.__dict__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_traverse_dict</span><span class="params">(self, instance_dict)</span>:</span></span><br><span class="line">        output = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> instance_dict.items():</span><br><span class="line">            output[key] = self._traverse(key, value)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_traverse</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(value, ToDictMixin):</span><br><span class="line">            <span class="keyword">return</span> value.to_dict()</span><br><span class="line">        <span class="keyword">elif</span> isinstance(value, dict):</span><br><span class="line">            <span class="keyword">return</span> self._traverse_dict(value)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(value, list):</span><br><span class="line">            <span class="keyword">return</span> [self._traverse(key, i) <span class="keyword">for</span> i <span class="keyword">in</span> value]</span><br><span class="line">        <span class="keyword">elif</span> hasattr(value, <span class="string">'__dict__'</span>):</span><br><span class="line">            <span class="keyword">return</span> self._traverse_dict(value.__dict__)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>
<p>使用示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span><span class="params">(ToDIctMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value, left=None, right=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这下把大量的Python对象转换到一个字典中变得容易多了。</span></span><br><span class="line">tree = BinaryTree(<span class="number">10</span>, left=BinaryTree(<span class="number">7</span>, right=BinaryTree(<span class="number">9</span>)),</span><br><span class="line">    right=BinaryTree(<span class="number">13</span>, left=BinaryTree(<span class="number">11</span>)))</span><br><span class="line">print(tree.to_dict())</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&#123;<span class="string">'left'</span>: &#123;<span class="string">'left'</span>: <span class="keyword">None</span>,</span><br><span class="line">         <span class="string">'right'</span>: &#123;<span class="string">'left'</span>: <span class="keyword">None</span>, <span class="string">'right'</span>: <span class="keyword">None</span>, <span class="string">'value'</span>: <span class="number">9</span>&#125;,</span><br><span class="line">         <span class="string">'value'</span>: <span class="number">7</span>&#125;,</span><br><span class="line"> <span class="string">'right'</span>: &#123;<span class="string">'left'</span>: &#123;<span class="string">'left'</span>: <span class="keyword">None</span>, <span class="string">'right'</span>: <span class="keyword">None</span>, <span class="string">'value'</span>: <span class="number">11</span>&#125;,</span><br><span class="line">         <span class="string">'right'</span>: <span class="keyword">None</span>,</span><br><span class="line">         <span class="string">'value'</span>: <span class="number">13</span>&#125;,</span><br><span class="line">  <span class="string">'value'</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在这个例子中，唯一的必须条件就是类中必须有一个to_dict方法和接收关键字参数的__init__构造方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonMixin</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_json</span><span class="params">(cls, data)</span>:</span></span><br><span class="line">        kwargs = json.loads(data)</span><br><span class="line">        <span class="keyword">return</span> cls(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_json</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> json.dumps(self.to_dict())</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatacenterRack</span><span class="params">(ToDictMixin, JsonMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, switch=None, machines=None)</span>:</span></span><br><span class="line">        self.switch = Switch(**switch)</span><br><span class="line">        self.machines = [Machine(**kwargs) <span class="keyword">for</span> kwargs <span class="keyword">in</span> machines]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span><span class="params">(ToDictMixin, JsonMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ports=None, speed=None)</span>:</span></span><br><span class="line">        self.ports = ports</span><br><span class="line">        self.speed = speed</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Machine</span><span class="params">(ToDictMixin, JsonMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cores=None, ram=None, disk=None)</span>:</span></span><br><span class="line">        self.cores = cores</span><br><span class="line">        self.ram = ram</span><br><span class="line">        self.disk = disk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将这些类从JSON传中序列化也是简单的。这里我校验了一下，保证数据可以在序列化和反序列化正常的转换。</span></span><br><span class="line">serialized = <span class="string">"""&#123;</span></span><br><span class="line"><span class="string">    "switch": &#123;"ports": 5, "speed": 1e9&#125;,</span></span><br><span class="line"><span class="string">    "machines": [</span></span><br><span class="line"><span class="string">        &#123;"cores": 8, "ram": 32e9, "disk": 5e12&#125;,</span></span><br><span class="line"><span class="string">        &#123;"cores": 4, "ram": 16e9, "disk": 1e12&#125;,</span></span><br><span class="line"><span class="string">        &#123;"cores": 2, "ram": 4e9, "disk": 500e9&#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;"""</span></span><br><span class="line"></span><br><span class="line">deserialized = DatacenterRack.from_json(serialized)</span><br><span class="line">roundtrip = deserialized.to_json()</span><br><span class="line"><span class="keyword">assert</span> json.loads(serialized) == json.loads(roundtrip)</span><br></pre></td></tr></table></figure>
<h3 id="第27条-多使用公共属性，而不是私有属性"><a href="#第27条-多使用公共属性，而不是私有属性" class="headerlink" title="第27条: 多使用公共属性，而不是私有属性"></a>第27条: 多使用公共属性，而不是私有属性</h3><h4 id="备忘录-18"><a href="#备忘录-18" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>Python 编译器无法严格保证 private 字段的私密性</li>
<li>不要盲目将属性设置为 private，而是应该从一开始就做好规划，并允子类更多地访问超类的内部的API</li>
<li>应该多用 protected 属性，并且在文档中把这些字段的合理用法告诉子类的开发者，而不要试图用 private 属性来限制子类的访问</li>
<li>只有当子类不受自己控制的收，才可以考虑使用 private 属性来避免名称冲突</li>
</ul>
<p>Python 里面沒有真正的 “private variable”，想存取都可以存取得到。</p>
<p>下面的程式看起來我们没办法得到 <code>__private_field</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.public_field = <span class="number">5</span></span><br><span class="line">        self.__private_field = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_private_field</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__private_field</span><br><span class="line"></span><br><span class="line">foo = MyObject()</span><br><span class="line">print(foo.__private_field) <span class="comment"># AttributeError</span></span><br></pre></td></tr></table></figure>
<p>但其实只是名称被改掉而已</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(foo.__dict__)</span><br><span class="line"># &#123;&apos;_MyObject__private_field&apos;: 10, &apos;public_field&apos;: 5&#125;</span><br><span class="line"></span><br><span class="line">print(foo._MyObject__private_field)</span><br></pre></td></tr></table></figure>
<p>一般来说 Python 惯例是在变数前加一个底线代表 <strong>protected variable </strong>，作用在于提醒开发者使用上要注意。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># This stores the user-supplied value for the object.</span></span><br><span class="line">        <span class="comment"># It should be coercible to a string. Once assigned for</span></span><br><span class="line">        <span class="comment"># the object it should be treated as immutable.</span></span><br><span class="line">        self._value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self._value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIntegerSubclass</span><span class="params">(MyClass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._value</span><br><span class="line"></span><br><span class="line">foo = MyIntegerSubclass(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">assert</span> foo.get_value() == <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>双底线的命名方式是为了避免父类和子类间的命名冲突，除此之外尽量避免使用这种命名。</p>
<h3 id="第28条-自定义容器类型要从collections-abc来继承"><a href="#第28条-自定义容器类型要从collections-abc来继承" class="headerlink" title="第28条:自定义容器类型要从collections.abc来继承"></a>第28条:自定义容器类型要从collections.abc来继承</h3><h4 id="备忘录-19"><a href="#备忘录-19" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>如果要定制的子类比较简单，那就可以直接从Python的容器类型（如list或dict）中继承</li>
<li>想正确实现自定义的容器类型，可能需要编写大量的特殊方法</li>
<li>编写自制的容器类型时，可以从collection.abc 模块的抽象类基类中继承，那些基类能确保我们的子类具备适当的接口及行为</li>
</ul>
<p><code>collections.abc</code> 里面的 abstract classes 的作用是让开发者方便地开发自己的 container ，例如 list。一般情況下继承list 就ok了，但是当结构比较复杂的时候就需要自己自定义，例如 list 有许多 方法，要一一实现有点麻烦。</p>
<p>下面程式中 SequenceNode 是想要拥有 list 功能的 binary tree。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value, left=None, right=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexableNode</span><span class="params">(BinaryNode)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_search</span><span class="params">(self, count, index)</span>:</span></span><br><span class="line">        found = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> self.left:</span><br><span class="line">            found, count = self.left._search(count, index)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found <span class="keyword">and</span> count == index:</span><br><span class="line">            found = self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found <span class="keyword">and</span> self.right:</span><br><span class="line">            found, count = self.right._search(count, index)</span><br><span class="line">        <span class="keyword">return</span> found, count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        found, _ = self._search(<span class="number">0</span>, index)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">'Index out of range'</span>)</span><br><span class="line">        <span class="keyword">return</span> found.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SequenceNode</span><span class="params">(IndexableNode)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        _, count = self._search(<span class="number">0</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p>以下是 SequenceNode的一些 list 常用的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tree = SequenceNode(</span><br><span class="line">	<span class="number">10</span>,</span><br><span class="line">    left=SequenceNode(</span><br><span class="line">    	<span class="number">5</span>,</span><br><span class="line">        left=SequenceNode(<span class="number">2</span>),</span><br><span class="line">        right=SequenceNode(</span><br><span class="line">        	<span class="number">6</span>, </span><br><span class="line">        	right=SequenceNode(<span class="number">7</span>))),</span><br><span class="line">    right=SequenceNode(</span><br><span class="line">		<span class="number">15</span>, </span><br><span class="line">		left=SequenceNode(<span class="number">11</span>)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Index 0 ='</span>, tree[<span class="number">0</span>]) </span><br><span class="line">print(<span class="string">'11 in the tree?'</span>, <span class="number">11</span> <span class="keyword">in</span> tree)</span><br><span class="line">print(<span class="string">'Tree has %d nodes'</span> % len(tree))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Index <span class="number">0</span> = <span class="number">2</span></span><br><span class="line">11 in the tree? True</span><br><span class="line">Tree has <span class="number">7</span> nodes</span><br></pre></td></tr></table></figure>
<p>但是使用者可能想使用像 <code>count()</code>以及 <code>index()</code>等 list 的 方法 ，这时候可以使用 <code>collections.abc</code>的 <strong>Sequence </strong>。子类只要实现 <code>__getitem__</code>以及 <code>__len__</code>， <strong>Sequence </strong>以及提供<code>count()</code>以及 <code>index()</code>了，而且如果子类没有实现类似 <strong>Sequence</strong> 的抽象基类所要求的每个方法，<code>collections.abc</code> 模块就会指出这个错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Sequence</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterNode</span><span class="params">(SequenceNode, Sequence)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">tree = BetterNode(</span><br><span class="line">   <span class="comment"># ...</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Index of 7 is'</span>, tree.index(<span class="number">7</span>))</span><br><span class="line">print(<span class="string">'Count of 10 is'</span>, tree.count(<span class="number">10</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Index of <span class="number">7</span> <span class="keyword">is</span> <span class="number">3</span></span><br><span class="line">Count of <span class="number">10</span> <span class="keyword">is</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="四、元类和属性"><a href="#四、元类和属性" class="headerlink" title="四、元类和属性"></a>四、元类和属性</h2><h3 id="第29条-用纯属性取代-get-和-set-方法"><a href="#第29条-用纯属性取代-get-和-set-方法" class="headerlink" title="第29条: 用纯属性取代 get 和 set 方法"></a>第29条: 用纯属性取代 get 和 set 方法</h3><h4 id="备忘录-20"><a href="#备忘录-20" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>使用public属性避免set和get方法，@property定义一些特别的行为</li>
<li>如果访问对象的某个属性的时候，需要表现出特殊的行为，那就用@property来定义这种行为</li>
<li>@property 方法应该遵循最小惊讶原则，而不应该产生奇怪的副作用</li>
<li>确保@property方法是快速的，如果是慢或者复杂的工作应该放在正常的方法里面</li>
</ul>
<p>示例1：</p>
<p>不要把 java 的那一套 getter 和 setter 带进来</p>
<p>not:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldResistor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">        self._ohms = ohms</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ohms</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._ohms</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_ohms</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">        self._ohms = ohms</span><br></pre></td></tr></table></figure>
<p>prefer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resistor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">        self.ohms = ohms</span><br><span class="line">        self.voltage = <span class="number">0</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<p>使用@property，来绑定一些特殊操作，但是不要产生奇怪的副作用，比如在getter里面做一些赋值的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoltageResistance</span><span class="params">(Resistor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">        super().__init__(ohms)</span><br><span class="line">        self._voltage = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 相当于 getter</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">voltage</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._voltage</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 相当于 setter</span></span><br><span class="line"><span class="meta">    @voltage.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">voltage</span><span class="params">(self, voltage)</span>:</span></span><br><span class="line">        self._voltage = voltage</span><br><span class="line">        self.current = self._voltage / self.ohms</span><br><span class="line"></span><br><span class="line">r2 = VoltageResistance(<span class="number">1e3</span>)</span><br><span class="line">print(<span class="string">'Before: %5r amps'</span> % r2.current)</span><br><span class="line"><span class="comment"># 会执行 setter 方法</span></span><br><span class="line">r2.voltage = <span class="number">10</span></span><br><span class="line">print(<span class="string">'After:  %5r amps'</span> % r2.current)</span><br></pre></td></tr></table></figure>
<h3 id="第30条-考虑-property来替代属性重构"><a href="#第30条-考虑-property来替代属性重构" class="headerlink" title="第30条: 考虑@property来替代属性重构"></a>第30条: 考虑@property来替代属性重构</h3><h4 id="备忘录-21"><a href="#备忘录-21" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>使用@property给已有属性扩展新需求</li>
<li>可以用 @property 来逐步完善数据模型</li>
<li>当@property太复杂了才考虑重构</li>
</ul>
<p>@property可以把简单的数值属性迁移为实时计算，只定义 getter 不定义 setter 那么就是一个只读属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bucket</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, period)</span>:</span></span><br><span class="line">        self.period_delta = timedelta(seconds=period)</span><br><span class="line">        self.reset_time = datetime.now()</span><br><span class="line">        self.max_quota = <span class="number">0</span></span><br><span class="line">        self.quota_consumed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">'Bucket(max_quota=%d, quota_consumed=%d)'</span> %</span><br><span class="line">                (self.max_quota, self.quota_consumed))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quota</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.max_quota - self.quota_consumed</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @quota.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quota</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        delta = self.max_quota - amount</span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># Quota being reset for a new period</span></span><br><span class="line">            self.quota_consumed = <span class="number">0</span></span><br><span class="line">            self.max_quota = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> delta &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># Quota being filled for the new period</span></span><br><span class="line">            <span class="keyword">assert</span> self.quota_consumed = <span class="number">0</span></span><br><span class="line">            self.max_quota = amount</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Quota being consumed during the period</span></span><br><span class="line">            <span class="keyword">assert</span> self.max_quota &gt;= self,quota_consumed</span><br><span class="line">            self.quota_consumed += delta</span><br></pre></td></tr></table></figure>
<p>这种写法的好处就在于：从前使用的Bucket.quota 的那些旧代码，既不需要做出修改，也不需要担心现在的Bucket类是如何实现的，可以轻松无痛扩展新功能。但是@property也不能滥用，而且@property的一个缺点就是无法被复用，同一套逻辑不能在不同的属性之间重复使用如果不停的编写@property方法，那就意味着当前这个类的代码写的确实很糟糕，此时应该重构了。</p>
<p>TODO</p>
<h3 id="第31条-用描述符来改写需要复用的-property-方法"><a href="#第31条-用描述符来改写需要复用的-property-方法" class="headerlink" title="第31条: 用描述符来改写需要复用的 @property 方法"></a>第31条: 用描述符来改写需要复用的 @property 方法</h3><h4 id="备忘录-22"><a href="#备忘录-22" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li><p>如果想复用 @property 方法及其验证机制，那么可以自定义描述符类</p>
</li>
<li><p>WeakKeyDictionary 可以保证描述符类不会泄露内存</p>
</li>
<li><p>通过描述符协议来实现属性的获取和设置操作时，不要纠结于<code>__getatttttribute__</code> 的方法的具体运作细节</p>
</li>
</ul>
<p><code>property</code>最大的问题是可能造成 duplicated code 这种 code smell。</p>
<p>下面的程式 <code>math_grade</code>以及 <code>math_grade</code>就有这样的问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._writing_grade = <span class="number">0</span></span><br><span class="line">        self._math_grade = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_grade</span><span class="params">(value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writing_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._writing_grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @writing_grade.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writing_grade</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._check_grade(value)</span><br><span class="line">        self._writing_grade = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">math_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._math_grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @math_grade.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">math_grade</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._check_grade(value)</span><br><span class="line">        self._math_grade = value</span><br></pre></td></tr></table></figure>
<p>可以使用 <strong>descriptor </strong>解決，下面的程式将重复的逻辑封装在 Grade 里面。但是這个程式根本 <strong>不能用 </strong>，因为存取到的是 class attributes，例如 <code>exam.writing_grade = 40</code>其实是<code>Exam.__dict__[&#39;writing_grade&#39;].__set__(exam, 40)</code>，这样所有 Exam 的 instances 都是存取到一样的东西 ( <code>Grade()</code>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, instance_type)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</span><br><span class="line">        self._value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span><span class="params">(object)</span>:</span></span><br><span class="line">    math_grade = Grade()</span><br><span class="line">    writing_grade = Grade()</span><br><span class="line">    science_grade = Grade()</span><br><span class="line"></span><br><span class="line">exam = Exam()</span><br><span class="line">exam.writing_grade = <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>解決方式是用个 dictionary 存起來，这里使用 <code>WeakKeyDictionary</code>避免 memory leak。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from weakref import WeakKeyDictionary</span><br><span class="line"></span><br><span class="line">class Grade(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._values = WeakKeyDictionary()</span><br><span class="line">    def __get__(self, instance, instance_type):</span><br><span class="line">        if instance is None: return self</span><br><span class="line">        return self._values.get(instance, 0)</span><br><span class="line"></span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        if not (0 &lt;= value &lt;= 100):</span><br><span class="line">            raise ValueError(&apos;Grade must be between 0 and 100&apos;)</span><br><span class="line">        self._values[instance] = value</span><br></pre></td></tr></table></figure>
<h3 id="第32条-用-getattr-getattribute-和-setattr-实现按需生产的属性"><a href="#第32条-用-getattr-getattribute-和-setattr-实现按需生产的属性" class="headerlink" title="第32条: 用 __getattr__, __getattribute__,  和__setattr__ 实现按需生产的属性"></a>第32条: 用 <code>__getattr__</code>, <code>__getattribute__</code>,  和<code>__setattr__</code> 实现按需生产的属性</h3><h4 id="备忘录-23"><a href="#备忘录-23" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>通过<code>__getttattr__</code> 和 <code>__setattr__</code>，我们可以用惰性的方式来加载并保存对象的属性</li>
<li>要理解 <code>__getattr__</code> 和 <code>__getattribute__</code> 的区别：前者只会在待访问的属性缺失时触发，而后者则会在每次访问属性的时候触发</li>
<li>如果要在<code>__getattributte__</code> 和 <code>__setattr__</code> 方法中访问实例属性，那么应该直接通过 super() 来做，以避免无限递归</li>
</ul>
<ul>
<li>obj.name，getattr和hasattr都会调用<strong>getattribute</strong>方法，如果name不在obj.<strong>dict</strong>里面，还会调用<strong>getattr</strong>方法，如果没有自定义<strong>getattr</strong>方法会AttributeError异常</li>
<li>只要有赋值操作（=，setattr）都会调用<strong>setattr</strong>方法（包括a = A()）</li>
</ul>
<p><code>__getattr__</code>和 <code>__getattribute__</code>都可以动态地存取 attributes ，不同点在于如果 <code>__dict__</code>找不到才会呼叫 <code>__getattr__</code>，而 <code>__getattribute__</code>每次都会被呼叫到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyDB</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.exists = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        value = <span class="string">'Value for %s'</span> % name</span><br><span class="line">        setattr(self, name, value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingLazyDB</span><span class="params">(LazyDB)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'Called __getattr__(%s)'</span> % name)</span><br><span class="line">        <span class="keyword">return</span> super().__getattr__(name)</span><br><span class="line"></span><br><span class="line">data = LoggingLazyDB()</span><br><span class="line">print(<span class="string">'exists:'</span>, data.exists)</span><br><span class="line">print(<span class="string">'foo:   '</span>, data.foo)</span><br><span class="line">print(<span class="string">'foo:   '</span>, data.foo)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidatingDB</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.exists = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'Called __getattribute__(%s)'</span> % name)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> super().__getattribute__(name)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            value = <span class="string">'Value for %s'</span> % name</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">data = ValidatingDB()</span><br><span class="line">print(<span class="string">'exists:'</span>, data.exists)</span><br><span class="line">print(<span class="string">'foo:   '</span>, data.foo)</span><br><span class="line">print(<span class="string">'foo:   '</span>, data.foo)</span><br></pre></td></tr></table></figure>
<p>可以控制什么 attributes 不应该被使用到，记得要丟 <strong>AttributeError </strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MissingPropertyDB</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> name == <span class="string">'bad_name'</span>:</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(<span class="string">'%s is missing'</span> % name)</span><br><span class="line">            value = <span class="string">'Value for %s'</span> % name</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    data = MissingPropertyDB()</span><br><span class="line">    data.foo  <span class="comment"># Test this works</span></span><br><span class="line">    data.bad_name</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    logging.exception(<span class="string">'Expected'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p><code>__setattr__</code>每次都会被呼叫到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingDB</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="comment"># Save some data to the DB log</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        super().__setattr__(name, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingSavingDB</span><span class="params">(SavingDB)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        print(<span class="string">'Called __setattr__(%s, %r)'</span> % (name, value))</span><br><span class="line">        super().__setattr__(name, value)</span><br></pre></td></tr></table></figure>
<p>很重要的一点是 <code>__setattr__</code>以及 <code>__getattribute__</code>一定要呼叫父类的 <code>__getattribute__</code>，避免无限循环下去。</p>
<p>这个会爆掉，因为存取 <code>self._data</code>又会呼叫 <code>__getattribute__</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BrokenDictionaryDB(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self._data = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def __getattribute__(self, name):</span><br><span class="line">        print(&apos;Called __getattribute__(%s)&apos; % name)</span><br><span class="line">        return self._data[name]</span><br></pre></td></tr></table></figure>
<p>呼叫 <code>super().__getattribute__(&#39;_data&#39;)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DictionaryDB(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self._data = data</span><br><span class="line"></span><br><span class="line">    def __getattribute__(self, name):</span><br><span class="line">        data_dict = super().__getattribute__(&apos;_data&apos;)</span><br><span class="line">        return data_dict[name]</span><br></pre></td></tr></table></figure>
<h3 id="第33条-用元类来验证子类"><a href="#第33条-用元类来验证子类" class="headerlink" title="第33条: 用元类来验证子类"></a>第33条: 用元类来验证子类</h3><h4 id="备忘录-24"><a href="#备忘录-24" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>通过元类，我们可以在生成子类对象之前，先验证子类的定义是否合乎规范</li>
<li>Python2 和 Python3 指定元类的语法略有不同</li>
</ul>
<ul>
<li>使用元类对类型对象进行验证</li>
<li>Python 系统把子类的整个 class 语句体处理完毕之后，就会调用其元类的<code>__new__</code> 方法</li>
</ul>
<h3 id="第34条-用元类来注册子类"><a href="#第34条-用元类来注册子类" class="headerlink" title="第34条: 用元类来注册子类"></a>第34条: 用元类来注册子类</h3><h4 id="备忘录-25"><a href="#备忘录-25" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>在构建模块化的 Python 程序时候，类的注册是一种很有用的模式</li>
</ul>
<ul>
<li>开发者每次从基类中继承子类的时，基类的元类都可以自动运行注册代码</li>
<li>通过元类来实现类的注册，可以确保所有子类都不会泄露，从而避免后续的错误</li>
</ul>
<p>首先，定义元类，我们要继承 type, python 默认会把那些类的 class 语句体中所含的相关内容，发送给元类的 new 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, class_dict)</span>:</span></span><br><span class="line">        print(meta, name, bases, class_dict)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, class_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是 python2 写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassInPython2</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = Meta</span><br><span class="line">    stuff = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassInPython3</span><span class="params">(object, metaclass=Meta)</span>:</span></span><br><span class="line">    stuff = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidatePolygon</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, class_dict)</span>:</span></span><br><span class="line">        <span class="comment"># Don't validate the abstract Polygon class</span></span><br><span class="line">        <span class="keyword">if</span> bases != (object,):</span><br><span class="line">            <span class="keyword">if</span> class_dict[<span class="string">'sides'</span>] &lt; <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'Polygons need 3+ sides'</span>)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, class_dict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span><span class="params">(object, metaclass=ValidatePolygon)</span>:</span></span><br><span class="line">    sides = <span class="keyword">None</span>  <span class="comment"># Specified by subclasses</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interior_angles</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (cls.sides - <span class="number">2</span>) * <span class="number">180</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span><span class="params">(Polygon)</span>:</span></span><br><span class="line">    sides = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">print(Triangle.interior_angles())</span><br></pre></td></tr></table></figure>
<h3 id="第35-用元类来注解类的属性"><a href="#第35-用元类来注解类的属性" class="headerlink" title="第35: 用元类来注解类的属性"></a>第35: 用元类来注解类的属性</h3><h4 id="备忘录-26"><a href="#备忘录-26" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>借助元类，我们可以在某个类完全定义好之前，率先修改该类的属性</li>
<li>描述符与元类能够有效的组合起来，以便对某种行为做出修饰，或者在程序运行时探查相关信息</li>
</ul>
<ul>
<li>如果把元类与描述符相结合，那就可以在不使用 weakerf 模块的前提下避免内存泄露</li>
</ul>
<h2 id="五、并行与并发"><a href="#五、并行与并发" class="headerlink" title="五、并行与并发"></a>五、并行与并发</h2><h3 id="第36条-用-subprocess-模块来管理子进程"><a href="#第36条-用-subprocess-模块来管理子进程" class="headerlink" title="第36条: 用 subprocess 模块来管理子进程"></a>第36条: 用 subprocess 模块来管理子进程</h3><h4 id="备忘录-27"><a href="#备忘录-27" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>使用 subprocess 模块运行子进程管理自己的输入和输出流</li>
<li>subprocess 可以并行执行最大化CPU的使用</li>
<li>communicate 的 timeout 参数避免死锁和被挂起的子进程</li>
</ul>
<p>最基本的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen(</span><br><span class="line">    [<span class="string">'echo'</span>, <span class="string">'Hello from the child!'</span>],</span><br><span class="line">    stdout=subprocess.PIPE)</span><br><span class="line">out, err = proc.communicate()</span><br><span class="line">print(out.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<p>传入资料</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_openssl</span><span class="params">(data)</span>:</span></span><br><span class="line">    env = os.environ.copy()</span><br><span class="line">    env[<span class="string">'password'</span>] = <span class="string">b'\xe24U\n\xd0Ql3S\x11'</span></span><br><span class="line">    proc = subprocess.Popen(</span><br><span class="line">        [<span class="string">'openssl'</span>, <span class="string">'enc'</span>, <span class="string">'-des3'</span>, <span class="string">'-pass'</span>, <span class="string">'env:password'</span>],</span><br><span class="line">        env=env,</span><br><span class="line">        stdin=subprocess.PIPE,</span><br><span class="line">        stdout=subprocess.PIPE)</span><br><span class="line">    proc.stdin.write(data)</span><br><span class="line">    proc.stdin.flush()  <span class="comment"># Ensure the child gets input</span></span><br><span class="line">    <span class="keyword">return</span> proc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_md5</span><span class="params">(input_stdin)</span>:</span></span><br><span class="line">    proc = subprocess.Popen(</span><br><span class="line">        [<span class="string">'md5'</span>],</span><br><span class="line">        stdin=input_stdin,</span><br><span class="line">        stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">return</span> proc</span><br></pre></td></tr></table></figure>
<p>模擬 <strong>pipes</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_procs = []</span><br><span class="line">hash_procs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    data = os.urandom(<span class="number">10</span>)</span><br><span class="line">    proc = run_openssl(data)</span><br><span class="line">    input_procs.append(proc)</span><br><span class="line">    hash_proc = run_md5(proc.stdout)</span><br><span class="line">    hash_procs.append(hash_proc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> input_procs:</span><br><span class="line">    proc.communicate()</span><br><span class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> hash_procs:</span><br><span class="line">    out, err = proc.communicate()</span><br><span class="line">    print(out.strip())</span><br></pre></td></tr></table></figure>
<h3 id="第37条-可以用线程来执行阻塞时I-O，但不要用它做平行计算"><a href="#第37条-可以用线程来执行阻塞时I-O，但不要用它做平行计算" class="headerlink" title="第37条: 可以用线程来执行阻塞时I/O，但不要用它做平行计算"></a>第37条: 可以用线程来执行阻塞时I/O，但不要用它做平行计算</h3><h4 id="备忘录-28"><a href="#备忘录-28" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>因为GIL，Python thread并不能并行运行多段代码</li>
<li>Python保留thread的两个原因：1.可以模拟多线程，2.多线程可以处理I/O阻塞的情况</li>
<li>Python thread可以并行执行多个系统调用，这使得程序能够在执行阻塞式I/O操作的同时，执行一些并行计算</li>
</ul>
<h3 id="第38条-在线程中使用Lock来防止数据竞争"><a href="#第38条-在线程中使用Lock来防止数据竞争" class="headerlink" title="第38条: 在线程中使用Lock来防止数据竞争"></a>第38条: 在线程中使用Lock来防止数据竞争</h3><h4 id="备忘录-29"><a href="#备忘录-29" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>虽然Python thread不能同时执行，但是Python解释器还是会打断操作数据的两个字节码指令，所以还是需要锁</li>
<li>thread模块的Lock类是Python的互斥锁实现</li>
</ul>
<p>比较有趣的是 <strong>Barrier </strong>這个 Python 3.2 才加进来的东西，以前要用 <strong>Semaphore </strong>來做。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Barrier</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockingCounter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, offset)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.count += offset</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockingCounter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, offset)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.count += offset</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(sensor_index, how_many, counter)</span>:</span></span><br><span class="line">    <span class="comment"># I have a barrier in here so the workers synchronize</span></span><br><span class="line">    <span class="comment"># when they start counting, otherwise it's hard to get a race</span></span><br><span class="line">    <span class="comment"># because the overhead of starting a thread is high.</span></span><br><span class="line">    BARRIER.wait()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(how_many):</span><br><span class="line">        <span class="comment"># Read from the sensor</span></span><br><span class="line">        counter.increment(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_threads</span><span class="params">(func, how_many, counter)</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        args = (i, how_many, counter)</span><br><span class="line">        thread = Thread(target=func, args=args)</span><br><span class="line">        threads.append(thread)</span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line">BARRIER = Barrier(<span class="number">5</span>)</span><br><span class="line">counter = LockingCounter()</span><br><span class="line">run_threads(worker, how_many, counter)</span><br><span class="line">print(<span class="string">'Counter should be %d, found %d'</span> %</span><br><span class="line">      (<span class="number">5</span> * how_many, counter.count))</span><br></pre></td></tr></table></figure>
<h3 id="第39条-用-Queue-来协调各线程之间的工作"><a href="#第39条-用-Queue-来协调各线程之间的工作" class="headerlink" title="第39条: 用 Queue 来协调各线程之间的工作"></a>第39条: 用 Queue 来协调各线程之间的工作</h3><h4 id="备忘录-30"><a href="#备忘录-30" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>管线是一种优秀的任务处理方式，它可以把处理流程划分为若干阶段，并使用多条Python线程同时执行这些任务</li>
<li>构建并发式的管线时，要注意许多问题，包括：如何防止某个阶段陷入持续等待的状态之中、如何停止工作线程，以及如何防止内存膨胀等</li>
<li>Queue类具备构建健壮并发管道的特性：阻塞操作，缓存大小和连接（join）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosableQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            item = self.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">is</span> self.SENTINEL:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="comment"># Cause the thread to exit</span></span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoppableWorker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.in_queue:</span><br><span class="line">            result = self.func(item)</span><br><span class="line">            self.out_queue.put(result)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">download_queue = ClosableQueue()</span><br><span class="line">resize_queue = ClosableQueue()</span><br><span class="line">upload_queue = ClosableQueue()</span><br><span class="line">done_queue = ClosableQueue()</span><br><span class="line">threads = [</span><br><span class="line">    StoppableWorker(download, download_queue, resize_queue),</span><br><span class="line">    StoppableWorker(resize, resize_queue, upload_queue),</span><br><span class="line">    StoppableWorker(upload, upload_queue, done_queue),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.start()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    download_queue.put(object())</span><br><span class="line">download_queue.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue.join()</span><br><span class="line">resize_queue.close()</span><br><span class="line">resize_queue.join()</span><br><span class="line">upload_queue.close()</span><br><span class="line">upload_queue.join()</span><br><span class="line">print(done_queue.qsize(), <span class="string">'items finished'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="第40条-考虑用协程来并发地运行多个函数"><a href="#第40条-考虑用协程来并发地运行多个函数" class="headerlink" title="第40条: 考虑用协程来并发地运行多个函数"></a>第40条: 考虑用协程来并发地运行多个函数</h3><h4 id="备忘录-31"><a href="#备忘录-31" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li><p>线程有三个大问题：</p>
<ul>
<li>需要特定工具去确定安全性</li>
<li>单个线程需要8M的内存</li>
<li>线程启动消耗</li>
</ul>
</li>
<li><p>coroutine只有1kb的内存消耗</p>
</li>
<li><p>generator可以通过send方法把值传递给yield</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        received = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">"Received:"</span>, received)</span><br><span class="line">it = my_coroutine()</span><br><span class="line">next(it)</span><br><span class="line">it.send(<span class="string">"First"</span>)</span><br><span class="line">(<span class="string">'Received:'</span>, <span class="string">'First'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Python2不支持直接yield generator，可以使用for循环yield</p>
</li>
</ul>
<h3 id="第41条-考虑用-concurrent-futures-来实现真正的并行计算"><a href="#第41条-考虑用-concurrent-futures-来实现真正的并行计算" class="headerlink" title="第41条: 考虑用 concurrent.futures 来实现真正的并行计算"></a>第41条: 考虑用 concurrent.futures 来实现真正的并行计算</h3><h4 id="备忘录-32"><a href="#备忘录-32" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>CPU瓶颈模块使用C扩展</li>
<li>concurrent.futures的multiprocessing可以并行处理一些任务，Python2没有这个模块</li>
<li>multiprocessing 模块所提供的那些高级功能，都特别复杂，开发者尽量不要直接使用它们</li>
</ul>
<p>使用 <code>concurrent.futures</code> 里面的 <strong>ProcessPoolExecutor </strong>可以很简单地平行处理 CPU-bound 的程式，省得用 <code>multiprocessing</code> 自定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">start = time()</span><br><span class="line">pool = ProcessPoolExecutor(max_workers=<span class="number">2</span>)  <span class="comment"># The one change</span></span><br><span class="line">results = list(pool.map(gcd, numbers))</span><br><span class="line">end = time()</span><br><span class="line">print(<span class="string">'Took %.3f seconds'</span> % (end - start))</span><br></pre></td></tr></table></figure>
<h2 id="六、内置模块"><a href="#六、内置模块" class="headerlink" title="六、内置模块"></a>六、内置模块</h2><h3 id="第42条-用-functools-wraps-定义函数修饰器"><a href="#第42条-用-functools-wraps-定义函数修饰器" class="headerlink" title="第42条: 用 functools.wraps 定义函数修饰器"></a>第42条: 用 functools.wraps 定义函数修饰器</h3><h4 id="备忘录-33"><a href="#备忘录-33" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li><p>装饰器可以对函数进行封装，但是会改变函数信息</p>
</li>
<li><p>使用 functools 的 warps 可以解决这个问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># …</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># …</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第43条-考虑用-contextlib-和with-语句来改写可复用的-try-finally-代码"><a href="#第43条-考虑用-contextlib-和with-语句来改写可复用的-try-finally-代码" class="headerlink" title="第43条: 考虑用 contextlib 和with 语句来改写可复用的 try/finally 代码"></a>第43条: 考虑用 contextlib 和with 语句来改写可复用的 try/finally 代码</h3><h4 id="备忘录-34"><a href="#备忘录-34" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>使用with语句代替try/finally，增加代码可读性</li>
<li>使用 contextlib 提供的 contextmanager 装饰函数就可以被 with 使用</li>
<li><p>with 和 yield 返回值使用</p>
<p><code>contextlib.contextmanager</code>，方便我们在做 <strong>context managers </strong>。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_level</span><span class="params">(level, name)</span>:</span></span><br><span class="line">    logger = logging.getLogger(name)</span><br><span class="line">    old_level = logger.getEffectiveLevel()</span><br><span class="line">    logger.setLevel(level)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> logger</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        logger.setLevel(old_level)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> log_level(logging.DEBUG, <span class="string">'my-log'</span>) <span class="keyword">as</span> logger:</span><br><span class="line">    logger.debug(<span class="string">'This is my message!'</span>)</span><br><span class="line">    logging.debug(<span class="string">'This will not print'</span>)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">'my-log'</span>)</span><br><span class="line">logger.debug(<span class="string">'Debug will not print'</span>)</span><br><span class="line">logger.error(<span class="string">'Error will print'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="第44条-用-copyreg-实现可靠的-pickle-操作"><a href="#第44条-用-copyreg-实现可靠的-pickle-操作" class="headerlink" title="第44条: 用 copyreg 实现可靠的 pickle 操作"></a>第44条: 用 copyreg 实现可靠的 pickle 操作</h3><h4 id="备忘录-35"><a href="#备忘录-35" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>pickle 模块只能序列化和反序列化确认没有问题的对象</li>
<li>copyreg的 pickle 支持属性丢失，版本和导入类表信息</li>
</ul>
<p>使用 <code>copyreg</code>這个内建的 module ，搭配 <code>pickle</code>使用。</p>
<p><code>pickle</code>使用上很简单，假设我们有个 class:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameState</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.level = <span class="number">0</span></span><br><span class="line">        self.lives = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">state = GameState()</span><br><span class="line">state.level += <span class="number">1</span>  <span class="comment"># Player beat a level</span></span><br><span class="line">state.lives -= <span class="number">1</span>  <span class="comment"># Player had to try again</span></span><br></pre></td></tr></table></figure>
<p>可以用 <code>pickle</code>保存 object</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">state_path = <span class="string">'/tmp/game_state.bin'</span></span><br><span class="line"><span class="keyword">with</span> open(state_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(state, f)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(state_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    state_after = pickle.load(f)</span><br><span class="line"><span class="comment"># &#123;'lives': 3, 'level': 1&#125;</span></span><br><span class="line">print(state_after.__dict__)</span><br></pre></td></tr></table></figure>
<p>但是如果增加了新的 field， <code>game_state.bin</code>load 回來的 object 当然不会有新的 field (points)，可是它仍然是 GameState 的 instance，这会造成混乱。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameState</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.level = <span class="number">0</span></span><br><span class="line">        self.lives = <span class="number">4</span></span><br><span class="line">        self.points = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(state_path, <span class="string">'rb'</span>) <span class="keyword">as</span> :</span><br><span class="line">    state_after = pickle.load(f)</span><br><span class="line"><span class="comment"># &#123;'lives': 3, 'level': 1&#125;</span></span><br><span class="line">print(state_after.__dict__)</span><br><span class="line"><span class="keyword">assert</span> isinstance(state_after, GameState)</span><br></pre></td></tr></table></figure>
<p>使用 <code>copyreg</code>可以解決这个问题，它可以注册用來 serialize Python 物件的函式。</p>
<h5 id="Default-Attribute-Values"><a href="#Default-Attribute-Values" class="headerlink" title="Default Attribute Values"></a>Default Attribute Values</h5><p><code>pickle_game_state()</code> 返回一个 tuple ，包含了拿來 unpickle 的函式以及传入函式的引数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copyreg</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameState</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=<span class="number">0</span>, lives=<span class="number">4</span>, points=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.level = level</span><br><span class="line">        self.lives = lives</span><br><span class="line">        self.points = points</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pickle_game_state</span><span class="params">(game_state)</span>:</span></span><br><span class="line">    kwargs = game_state.__dict__</span><br><span class="line">    <span class="keyword">return</span> unpickle_game_state, (kwargs,)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpickle_game_state</span><span class="params">(kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> GameState(**kwargs)</span><br><span class="line"></span><br><span class="line">copyreg.pickle(GameState, pickle_game_state)</span><br></pre></td></tr></table></figure>
<h5 id="Versioning-Classes"><a href="#Versioning-Classes" class="headerlink" title="Versioning Classes"></a>Versioning Classes</h5><p><code>copyreg</code>也可以拿來记录版本，达到向后相容的目的。</p>
<p>如果原先的 class 如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameState</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=<span class="number">0</span>, lives=<span class="number">4</span>, points=<span class="number">0</span>, magic=<span class="number">5</span>)</span>:</span></span><br><span class="line">        self.level = level</span><br><span class="line">        self.lives = lives</span><br><span class="line">        self.points = points</span><br><span class="line">        self.magic = magic</span><br><span class="line"></span><br><span class="line">state = GameState()</span><br><span class="line">state.points += <span class="number">1000</span></span><br><span class="line">serialized = pickle.dumps(state)</span><br></pre></td></tr></table></figure>
<p>后来修改了，拿掉 lives ，这时原先使用预设参数的做法不能用了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameState</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=<span class="number">0</span>, points=<span class="number">0</span>, magic=<span class="number">5</span>)</span>:</span></span><br><span class="line">        self.level = level</span><br><span class="line">        self.points = points</span><br><span class="line">        self.magic = magic</span><br><span class="line"></span><br><span class="line"><span class="comment"># TypeError: __init__() got an unexpected keyword argument 'lives'</span></span><br><span class="line">pickle.loads(serialized)</span><br></pre></td></tr></table></figure>
<p>在 serialize 时多加上版本号， deserialize 时加以判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pickle_game_state</span><span class="params">(game_state)</span>:</span></span><br><span class="line">    kwargs = game_state.__dict__</span><br><span class="line">    kwargs[<span class="string">'version'</span>] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> unpickle_game_state, (kwargs,)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpickle_game_state</span><span class="params">(kwargs)</span>:</span></span><br><span class="line">    version = kwargs.pop(<span class="string">'version'</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> version == <span class="number">1</span>:</span><br><span class="line">        kwargs.pop(<span class="string">'lives'</span>)</span><br><span class="line">    <span class="keyword">return</span> GameState(**kwargs)</span><br><span class="line"></span><br><span class="line">copyreg.pickle(GameState, pickle_game_state)</span><br></pre></td></tr></table></figure>
<h5 id="Stable-Import-Paths"><a href="#Stable-Import-Paths" class="headerlink" title="Stable Import Paths"></a>Stable Import Paths</h5><p>重写程式时，如果 class 改名了，想要 load  的 serialized 物件当然不能用，但还是可以使用 <code>copyreg</code>解決。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterGameState</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=<span class="number">0</span>, points=<span class="number">0</span>, magic=<span class="number">5</span>)</span>:</span></span><br><span class="line">        self.level = level</span><br><span class="line">        self.points = points</span><br><span class="line">        self.magic = magic</span><br><span class="line"></span><br><span class="line">copyreg.pickle(BetterGameState, pickle_game_state)</span><br></pre></td></tr></table></figure>
<p>可以发现 <code>unpickle_game_state()</code>的 path 进入 dump 出來的资料中，当然这样做的缺点就是 <code>unpickle_game_state()</code>所在的 module 不能改 path 了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">state = BetterGameState()</span><br><span class="line">serialized = pickle.dumps(state)</span><br><span class="line">print(serialized[:<span class="number">35</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="string">b'\x80\x03c__main__\nunpickle_game_state\nq\x00&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="第45条-用-datetime-替代-time-来处理本地时间"><a href="#第45条-用-datetime-替代-time-来处理本地时间" class="headerlink" title="第45条: 用 datetime 替代 time 来处理本地时间"></a>第45条: 用 datetime 替代 time 来处理本地时间</h3><h4 id="备忘录-36"><a href="#备忘录-36" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>不要使用time模块在转换不同时区的时间</li>
<li>而用datetime配合 pytz 转换</li>
<li>总数保持UTC时间，最后面再输出本地时间</li>
</ul>
<h3 id="第46条-使用内置算法与数据结构"><a href="#第46条-使用内置算法与数据结构" class="headerlink" title="第46条: 使用内置算法与数据结构"></a>第46条: 使用内置算法与数据结构</h3><h4 id="备忘录-37"><a href="#备忘录-37" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>使用 Python 内置的模块来描述各种算法和数据结构</li>
<li>开发者不应该自己去重新实现他们，因为我们很难把它写好</li>
</ul>
<p>内置算法和数据结构</p>
<ul>
<li><p>collections.deque</p>
</li>
<li><p>collections.OrderedDict</p>
</li>
<li><p>collection.defaultdict</p>
</li>
<li><p>heapq模块操作list（优先队列）：heappush，heappop和nsmallest</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line">heappush(a, <span class="number">5</span>)</span><br><span class="line">heappush(a, <span class="number">3</span>)</span><br><span class="line">heappush(a, <span class="number">7</span>)</span><br><span class="line">heappush(a, <span class="number">4</span>)</span><br><span class="line">print(heappop(a), heappop(a), heappop(a), heappop(a))</span><br><span class="line"><span class="comment"># &gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"># 3 4 5 7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bisect模块：bisect_left可以对有序列表进行高效二分查找</p>
</li>
<li><p>itertools模块（Python2不一定支持）：</p>
<ul>
<li>连接迭代器：chain，cycle，tee和zip_longest</li>
<li>过滤：islice，takewhile，dropwhile，filterfalse</li>
<li>组合不同迭代器：product，permutations和combination</li>
</ul>
</li>
</ul>
<h3 id="第47-条-在重视-精确度的场合，应该使用-decimal"><a href="#第47-条-在重视-精确度的场合，应该使用-decimal" class="headerlink" title="第47 条: 在重视 精确度的场合，应该使用 decimal"></a>第47 条: 在重视 精确度的场合，应该使用 decimal</h3><h4 id="备忘录-38"><a href="#备忘录-38" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>高精度要求的使用 Decimal 处理，如对舍入行为要求很严的场合，eg: 涉及货币计算的场合</li>
</ul>
<h3 id="第48条-学会安装由-Python-开发者社区所构建的模块"><a href="#第48条-学会安装由-Python-开发者社区所构建的模块" class="headerlink" title="第48条: 学会安装由 Python 开发者社区所构建的模块"></a>第48条: 学会安装由 Python 开发者社区所构建的模块</h3><ul>
<li>在 <a href="https://pypi.python.org" target="_blank" rel="noopener">https://pypi.python.org</a> 查找通用模块，并且用pip安装</li>
</ul>
<h2 id="七、协作开发"><a href="#七、协作开发" class="headerlink" title="七、协作开发"></a>七、协作开发</h2><h3 id="第49条-为每个函数、类和模块编写文档字符串"><a href="#第49条-为每个函数、类和模块编写文档字符串" class="headerlink" title="第49条: 为每个函数、类和模块编写文档字符串"></a>第49条: 为每个函数、类和模块编写文档字符串</h3><h3 id="第50条-用包来安排模块，并提供稳固的-API"><a href="#第50条-用包来安排模块，并提供稳固的-API" class="headerlink" title="第50条: 用包来安排模块，并提供稳固的 API"></a>第50条: 用包来安排模块，并提供稳固的 API</h3><h3 id="第51条-为自编的模块定义根异常，以便将调用者与-API-相隔离"><a href="#第51条-为自编的模块定义根异常，以便将调用者与-API-相隔离" class="headerlink" title="第51条: 为自编的模块定义根异常，以便将调用者与 API 相隔离"></a>第51条: 为自编的模块定义根异常，以便将调用者与 API 相隔离</h3><h3 id="第52条-用适当的方式打破循环依赖问题"><a href="#第52条-用适当的方式打破循环依赖问题" class="headerlink" title="第52条: 用适当的方式打破循环依赖问题"></a>第52条: 用适当的方式打破循环依赖问题</h3><h3 id="第53条-用虚拟环境隔离项目，并重建其依赖关系"><a href="#第53条-用虚拟环境隔离项目，并重建其依赖关系" class="headerlink" title="第53条: 用虚拟环境隔离项目，并重建其依赖关系"></a>第53条: 用虚拟环境隔离项目，并重建其依赖关系</h3><h2 id="八、部署"><a href="#八、部署" class="headerlink" title="八、部署"></a>八、部署</h2><h3 id="第54条-考虑用模块级别的代码来配置不同的部署环境"><a href="#第54条-考虑用模块级别的代码来配置不同的部署环境" class="headerlink" title="第54条: 考虑用模块级别的代码来配置不同的部署环境"></a>第54条: 考虑用模块级别的代码来配置不同的部署环境</h3><h3 id="第55条-通过-repr-字符串来输出调试信息"><a href="#第55条-通过-repr-字符串来输出调试信息" class="headerlink" title="第55条: 通过 repr 字符串来输出调试信息"></a>第55条: 通过 repr 字符串来输出调试信息</h3><h4 id="备忘录-39"><a href="#备忘录-39" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>repr作用于内置类型会产生可打印的字符串，eval可以获得这个字符串的原始值</li>
<li><strong>repr</strong>自定义上面输出的字符串</li>
</ul>
<h3 id="第56条-用-unittest-来测试全部代码"><a href="#第56条-用-unittest-来测试全部代码" class="headerlink" title="第56条: 用 unittest 来测试全部代码"></a>第56条: 用 unittest 来测试全部代码</h3><h4 id="备忘录-40"><a href="#备忘录-40" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>使用unittest编写测试用例，不光是单元测试，集成测试也很重要</li>
<li>继承TestCase，并且每个方法名都以test开始</li>
</ul>
<h3 id="第57条-考虑用-pdb-实现交互调试"><a href="#第57条-考虑用-pdb-实现交互调试" class="headerlink" title="第57条: 考虑用 pdb 实现交互调试"></a>第57条: 考虑用 pdb 实现交互调试</h3><h4 id="备忘录-41"><a href="#备忘录-41" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>启用pdb，然后在配合shell命令调试 import pdb; pdb.set_trace();</li>
</ul>
<h3 id="第58条-先分析性能再优化"><a href="#第58条-先分析性能再优化" class="headerlink" title="第58条: 先分析性能再优化"></a>第58条: 先分析性能再优化</h3><ul>
<li>cProfile 比 profile更精准<ul>
<li>ncalls:调用次数</li>
<li>tottime:函数自身耗时，不包括调用函数的耗时</li>
<li>cumtime:包括调用的函数耗时</li>
</ul>
</li>
</ul>
<h3 id="第59条-用-tracemaloc-来掌握内存的使用及泄露情况"><a href="#第59条-用-tracemaloc-来掌握内存的使用及泄露情况" class="headerlink" title="第59条: 用 tracemaloc 来掌握内存的使用及泄露情况"></a>第59条: 用 tracemaloc 来掌握内存的使用及泄露情况</h3><h4 id="备忘录-42"><a href="#备忘录-42" class="headerlink" title="备忘录"></a>备忘录</h4><ul>
<li>gc模块可以知道有哪些对象存在，但是不知道怎么分配的</li>
<li>tracemalloc可以得到内存的使用情况，但是只在Python3.4及其以上版本提供</li>
</ul>
<h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><p><a href="https://github.com/ihongChen/Effective-python-ex" target="_blank" rel="noopener">代码</a></p>
<p><a href="https://pan.baidu.com/s/19nMcvcWgPMe8Ayo1hqCj9w" target="_blank" rel="noopener">Effective Python(英文版) PDF</a>  密码: 7v9r</p>
<p><a href="https://pan.baidu.com/s/1tgvmcKLSIHuG37jLpbyQMg" target="_blank" rel="noopener">Effecttive Python(中文不完整非扫描版) PDF</a>  密码: 86bm</p>
<p><a href="https://pan.baidu.com/s/1_1oXO_Dd2Kvl7qPYdPeJ6g" target="_blank" rel="noopener">Effective Python(中文扫描版) PDF</a>   密码: dg7w</p>

                
  </div>

</article>

   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/04/29/其他/nginx 实践/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2018/05/01/Ubuntu/Ubuntu 配置笔记/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>





   
      <div class="git"></div>
   
</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives"
              rel="noopener noreferrer"
              target="_self"
              >
              blog
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'molscar';
    
    var disqus_url = 'http://mu-mo.top/2018/05/01/Python/effective python学习笔记/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//molscar.disqus.com/count.js" async></script>



    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
